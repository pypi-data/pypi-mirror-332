import multiprocessing as mp
from typing import Any, List, Mapping, Optional, Tuple, Union

from pydantic import Field
from typing_extensions import Literal

from luna_sdk.schemas.solver_parameters.base_parameter import BaseParameter

# The default absolute tolerance that should be used for `numpy.isclose(...)`
# calls. Equal to the default used in `numpy.isclose(..)`.
DEFAULT_ATOL: float = 1.0e-8

# The default relative tolerance that should be used for ``numpy.isclose(...)``
# calls. Equal to the default used in ``numpy.isclose(..)``.
DEFAULT_RTOL: float = 1.0e-5

# The default timeout used for solver run with a specified target.
# Number of seconds before routine halts. Default is 2592000 for dimod.qbsolv.
DEFAULT_TIMEOUT: int = 10

# The number of processes that should be used for parallel solving.
# Default is `mp.cpu_count()`.
DEFAULT_MULTIPROCESSING_CPU_COUNT: int = mp.cpu_count()

# The maximum retries of a dramatiq actor.
# Default is 0.
DRAMATIQ_ACTOR_MAX_RETRIES: int = 0


class BaseSolver(BaseParameter):
    timeout: Optional[Any] = None


class Tabu(BaseParameter):
    """
    Parameters
    ----------
    num_reads: Optional[int]
        Number of reads. Each read is generated by one run of the tabu algorithm. If
        `num_reads` is not explicitly given, it is selected to match the number of
        initial states given. If initial states are not provided, only one read is
        performed.
    tenure: Optional[int]
        Tabu tenure, which is the length of the tabu list, or number of recently
        explored solutions kept in memory. Default is a quarter of the number of problem
        variables up to a maximum value of 20.
    timeout: float
        Maximum running time per read in milliseconds.
    initial_states_generator: Literal['none', 'tile', 'random']
        Defines the expansion of `initial_states` if fewer than `num_reads` are
        specified:
        'none': if the number of initial states specified is smaller than `num_reads`,
        raises ``ValueError``.
        'tile': reuses the specified initial states if fewer than `num_reads` or
        truncates if greater.
        'random': expands the specified initial states with randomly generated states if
        fewer than `num_reads` or truncates if greater.
    """

    num_reads: Optional[int] = None
    tenure: Optional[int] = Field(default=None, le=20)
    timeout: float = 100
    initial_states_generator: Literal["none", "tile", "random"] = "random"


class SimulatedAnnealing(BaseParameter):
    """
    Parameters
    ----------
    num_reads: Optional[int]
        Number of reads. Each read is generated by one run of the simulated annealing
        algorithm. If `num_reads` is not explicitly given, it is selected to match the
        number of initial states given. If initial states are not provided, only one
        read is performed.
    num_sweeps: Optional[int]
        Number of sweeps used in annealing.
    beta_range: Union[List[float], Tuple[float, float], NoneType]
        A 2-tuple defining the beginning and end of the beta schedule, where beta is the
        inverse temperature. The schedule is applied linearly in beta. Default range is
        set based on the total bias associated with each node.
    beta_schedule_type: Literal['linear', 'geometric']
        Beta schedule type, or how the beta values are interpolated between the given
        'beta_range'.
    initial_states_generator: Literal['none', 'tile', 'random']
        Defines the expansion of `initial_states` if fewer than `num_reads` are
        specified:
        'none:' if the number of initial states specified is smaller than `num_reads`,
        raises an error.
        'tile': reuses the specified initial states if fewer than `num_reads` or
        truncates if greater.
        'random': expands the specified initial states with randomly generated states if
        fewer than `num_reads` or truncates if greater.
    """

    num_reads: Optional[int] = None
    num_sweeps: Optional[int] = 1_000
    beta_range: Optional[Union[List[float], Tuple[float, float]]] = None
    beta_schedule_type: Literal["linear", "geometric"] = "geometric"
    initial_states_generator: Literal["none", "tile", "random"] = "random"


class Decomposer(BaseParameter):
    """
    Parameters
    ----------
    size: int
        Nominal number of variables in the subproblem. Actual subproblem can be smaller,
        depending on other parameters (e.g. `min_gain`).
    min_gain: Optional[float]
        Minimum reduction required to BQM energy, given the current sample. A variable
        is included in the subproblem only if inverting its sample value reduces energy
        by at least this amount.
    rolling: bool
        If True, successive calls for the same problem (with possibly different samples)
        produce subproblems on different variables, selected by rolling down the list of
        all variables sorted by decreasing impact.
    rolling_history: float
        Fraction of the problem size, as a float in range 0.0 to 1.0, that should
        participate in the rolling selection. Once reached, subproblem unrolling is
        reset. Min: 0.0, Max: 1.0
    silent_rewind: bool
        If False, raises :exc:`EndOfStream` when resetting/rewinding the subproblem
        generator upon the reset condition for unrolling.
    traversal: Literal['energy', 'bfs', 'pfs']
        Traversal algorithm used to pick a subproblem of `size` variables. Options are:
        energy: Use the next `size` variables in the list of variables ordered by
        descending energy impact.
        bfs: Breadth-first traversal seeded by the next variable in the energy impact
        list.
        pfs: Priority-first traversal seeded by variables from the energy impact list,
        proceeding with the variable on the search boundary that has the highest energy
        impact.
    """

    size: int = 10
    min_gain: Optional[float] = None
    rolling: bool = True
    rolling_history: float = Field(default=1.0, ge=0.0, le=1.0)
    silent_rewind: bool = True
    traversal: Literal["energy", "bfs", "pfs"] = "energy"


class FixedTemperatureSampler(BaseParameter):
    """
    Parameters
    ----------
    num_sweeps: int
        Number of sweeps for the sampler.
    num_reads: Optional[int]
        Number of reads for the sampler.
    """

    num_sweeps: int = 10_000
    num_reads: Optional[int] = None


class EmbeddingParameters(BaseParameter):
    """
    Parameters
    ----------
    max_no_improvement: int
        Maximum number of failed iterations to improve the current solution, where each
        iteration attempts to find an embedding for each variable of S such that it is
        adjacent to all its neighbours.
    random_seed: Optional[int]
        Seed for the random number generator. If None, seed is set by `os.urandom()`.
    timeout: int
        Algorithm gives up after `timeout` seconds.
    max_beta: Optional[float]
        Qubits are assigned weight according to a formula (beta^n) where n is the number
        of chains containing that qubit. This value should never be less than or equal
        to 1. If None, `max_beta` is effectively infinite.
    tries: int
        Number of restart attempts before the algorithm stops. On D-WAVE 2000Q, a
        typical restart takes between 1 and 60 seconds.
    inner_rounds: Optional[int]
        The algorithm takes at most this many iterations between restart attempts;
        restart attempts are typically terminated due to `max_no_improvement`. If None,
        `inner_rounds` is effectively infinite.
    chainlength_patience: int
        Maximum number of failed iterations to improve chain lengths in the current
        solution, where each iteration attempts to find an embedding for each variable
        of S such that it is adjacent to all its neighbours.
    max_fill: Optional[int]
        Restricts the number of chains that can simultaneously incorporate the same
        qubit during the search. Values above 63 are treated as 63. If None, `max_fill`
        is effectively infinite.
    threads: int
        Maximum number of threads to use. Note that the parallelization is only
        advantageous where the expected degree of variables is significantly greater
        than the number of threads. Min: 1.
    return_overlap: bool
        This function returns an embedding, regardless of whether or not qubits are used
        by multiple variables. `return_overlap` determines the function's return value.
        If True, a 2-tuple is returned, in which the first element is the embedding and
        the second element is a bool representing the embedding validity. If False, only
        an embedding is returned.
    skip_initialization: bool
        Skip the initialization pass. Note that this only works if the chains passed in
        through `initial_chains` and `fixed_chains` are semi-valid. A semi-valid
        embedding is a collection of chains such that every adjacent pair of variables
        (u,v) has a coupler (p,q) in the hardware graph where p is in chain(u) and q is
        in chain(v). This can be used on a valid embedding to immediately skip to the
        chain length improvement phase. Another good source of semi-valid embeddings is
        the output of this function with the `return_overlap` parameter enabled.
    initial_chains: Any
        Initial chains inserted into an embedding before `fixed_chains` are placed,
        which occurs before the initialization pass. These can be used to restart the
        algorithm in a similar state to a previous embedding; for example, to improve
        chain length of a valid embedding or to reduce overlap in a semi-valid embedding
        (see `skip_initialization`) previously returned by the algorithm. Missing or
        empty entries are ignored. Each value in the dictionary is a list of qubit
        labels.
    fixed_chains: Any
        Fixed chains inserted into an embedding before the initialization pass. As the
        algorithm proceeds, these chains are not allowed to change, and the qubits used
        by these chains are not used by other chains. Missing or empty entries are
        ignored. Each value in the dictionary is a list of qubit labels.
    restrict_chains: Any
        Throughout the algorithm, it is guaranteed that chain[i] is a subset of
        `restrict_chains[i]` for each i, except those with missing or empty entries.
        Each value in the dictionary is a list of qubit labels.
    suspend_chains: Any
        This is a metafeature that is only implemented in the Python interface.
        `suspend_chains[i]` is an iterable of iterables; for example,
        `suspend_chains[i] = [blob_1, blob_2]`, with each blob_j an iterable of target
        node labels.
        This enforces the following:
            for each suspended variable i,
                for each blob_j in the suspension of i,
                    at least one qubit from blob_j will be contained in the chain for i
        miminorminer accomplishes this through the following problem transformation for
        each iterable blob_j in `suspend_chains[i]`,
            Add an auxiliary node Zij to both source and target graphs
            Set fixed_chains[Zij] = [Zij]
            Add the edge (i,Zij) to the source graph
            Add the edges (q,Zij) to the target graph for each q in blob_j
    """

    max_no_improvement: int = 10
    random_seed: Optional[int] = None
    timeout: int = 1_000
    max_beta: Optional[float] = None
    tries: int = 10
    inner_rounds: Optional[int] = None
    chainlength_patience: int = 10
    max_fill: Optional[int] = None
    threads: int = Field(default=1, ge=1)
    return_overlap: bool = False
    skip_initialization: bool = False
    initial_chains: Any = ()
    fixed_chains: Any = ()
    restrict_chains: Any = ()
    suspend_chains: Any = ()


class AutoEmbeddingParams(BaseParameter):
    """
    Parameters
    ----------
    embedding_parameters: EmbeddingParameters
        Embedding parameters for the auto embedding.
    """

    embedding_parameters: EmbeddingParameters = EmbeddingParameters()


class Embedding(BaseParameter):
    """
    Parameters
    ----------
    chain_strength: Union[float, Mapping, NoneType]
        Sets the coupling strength between qubits representing variables that form a
        `chain`. Mappings should specify the required chain strength for each variable.
        By default, `chain_strength` is calculated with
        `~dwave.embedding.chain_strength.uniform_torque_compensation`.
    chain_break_fraction: bool
        Add a `chain_break_fraction` field to the unembedded response with the fraction
        of chains broken before unembedding.
    embedding_parameters: EmbeddingParameters
        Embedding parameters for the embedding.
    """

    chain_strength: Optional[Union[float, Mapping]] = None
    chain_break_fraction: bool = True
    embedding_parameters: EmbeddingParameters = EmbeddingParameters()


class SamplingParams(BaseParameter):
    """
    Parameters
    ----------
    anneal_offsets: Optional[Any]
        Anneal offsets for the sampling.
    anneal_schedule: Optional[Any]
        Anneal schedule for the sampling.
    annealing_time: Optional[Any]
        Annealing time for the sampling.
    auto_scale: Optional[Any]
        Whether to auto scale for the sampling.
    fast_anneal: bool
        Use the fast-anneal protocol instead of the standard anneal.
    flux_biases: Optional[Any]
        Flux biases for the sampling.
    flux_drift_compensation: bool
        Whether to use flux drift compensation for the sampling.
    h_gain_schedule: Optional[Any]
        H gain schedule for the sampling.
    initial_state: Optional[Any]
        Initial state for the sampling.
    max_answers: Optional[int]
        Maximum number of answers for the sampling. Min: 1
    num_reads: int
        Number of reads for the sampling. Min: 1
    programming_thermalization: Optional[float]
        Programming thermalization for the sampling. Has to be positive.
    readout_thermalization: Optional[float]
        Readout thermalization for the sampling. Has to be positive.
    reduce_intersample_correlation: bool
        Whether to reduce intersample correlation for the sampling.
    reinitialize_state: Optional[bool]
        Whether to reinitialize state for the sampling. Should be `None` if
        `initial_state` is `None`.
    """

    anneal_offsets: Optional[Any] = None
    anneal_schedule: Optional[Any] = None
    annealing_time: Optional[Any] = None
    auto_scale: Optional[Any] = None
    fast_anneal: bool = False
    flux_biases: Optional[Any] = None
    flux_drift_compensation: bool = True
    h_gain_schedule: Optional[Any] = None
    initial_state: Optional[Any] = None
    max_answers: Optional[int] = Field(default=None, ge=1)
    num_reads: int = Field(default=1, ge=1)
    programming_thermalization: Optional[float] = Field(default=None, gt=0)
    readout_thermalization: Optional[float] = Field(default=None, gt=0)
    reduce_intersample_correlation: bool = False
    reinitialize_state: Optional[bool] = None


class Qpu(BaseParameter):
    """
    Parameters
    ----------
    num_reads: int
        Number of states (output solutions) to read from the sampler.
    num_retries: int
        Number of times the sampler will retry to embed if a failure occurs.
    sampling_params: SamplingParams
        Sampling parameters for the QPU. See https://docs.dwavesys.com/docs/latest/c_solver_parameters.html
        for more details.
    auto_embedding_params: AutoEmbeddingParams
        Auto embedding parameters for the QPU. See https://docs.ocean.dwavesys.com/projects/system/en/stable/reference/generated/minorminer.find_embedding.html
        for more details.
    """

    num_reads: int = 100
    num_retries: int = 0
    sampling_params: SamplingParams = SamplingParams()
    auto_embedding_params: AutoEmbeddingParams = AutoEmbeddingParams()


class Loop(BaseParameter):
    """
    Parameters
    ----------
    max_iter: Optional[int]
        Maximum number of iterations.
    max_time: int
        Time in seconds after which the algorithm will stop.
    convergence: int
        Number of iterations with unchanged output to terminate algorithm.
    target: Optional[float]
        Energy level that the algorithm tries to reach.
    rtol: float
        Relative tolerance for convergence.
    rtol: float
        Relative tolerance for convergence.
    atol: float
        Absolute tolerance for convergence.
    """

    max_iter: Optional[int] = 100
    max_time: int = 5
    convergence: int = 3
    target: Optional[float] = None
    rtol: float = DEFAULT_RTOL
    atol: float = DEFAULT_ATOL


class QBSOLVLike(BaseParameter):
    """
    Parameters
    ----------
    decomposer_size: int
        Size for the decomposer.
    rolling: bool
        Whether to use rolling for the solver.
    rolling_history: float
        Rolling history for the solver.
    cpu_count_multiplier: int
        CPU count multiplier for the solver.
    loop: Loop
        Parameters for the main loop of the algorithm.
    """

    decomposer_size: int = 50
    rolling: bool = True
    rolling_history: float = 0.15
    cpu_count_multiplier: int = 1
    loop: Loop = Loop()
