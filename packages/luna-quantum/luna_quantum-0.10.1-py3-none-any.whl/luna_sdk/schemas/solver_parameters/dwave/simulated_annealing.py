from typing import Any, Optional, Sequence

from typing_extensions import Literal

from luna_sdk.schemas.solver_parameters.dwave import SimulatedAnnealing


class SimulatedAnnealingParameters(SimulatedAnnealing):
    """
    Simulated Annealing finds the solution to a problem using a annealing process.
    Initially, random states are chosen in the solution landscape.
    Afterwards, as the temperature decreases, states are chosen that are more energetically favorable.
    At the end of the complete annealing process, the resulting states make up the solution.

    Parameters
    ----------
    num_reads: Optional[int]
        Number of reads. Each read is generated by one run of the simulated annealing
        algorithm. If `num_reads` is not explicitly given, it is selected to match the
        number of initial states given. If initial states are not provided, only one
        read is performed.
    num_sweeps: Optional[int]
        Number of sweeps used in annealing.
    beta_range: Union[List[float], Tuple[float, float], NoneType]
        A 2-tuple defining the beginning and end of the beta schedule, where beta is the
        inverse temperature. The schedule is applied linearly in beta. Default range is
        set based on the total bias associated with each node.
    beta_schedule_type: Literal['linear', 'geometric']
        Beta schedule type, or how the beta values are interpolated between the given
        'beta_range'.
    initial_states_generator: Literal['none', 'tile', 'random']
        Defines the expansion of `initial_states` if fewer than `num_reads` are
        specified:
        'none:' if the number of initial states specified is smaller than `num_reads`,
        raises an error.
        'tile': reuses the specified initial states if fewer than `num_reads` or
        truncates if greater.
        'random': expands the specified initial states with randomly generated states if
        fewer than `num_reads` or truncates if greater.
    num_sweeps_per_beta: int
        Number of sweeps to perform at each `beta`. One sweep consists of a sequential
        Metropolis update of all spins.
    seed: Optional[int]
        Seed to use for the PRNG. Specifying a particular seed with a constant set of
        parameters produces identical results. If not provided, a random seed is chosen.
    beta_schedule: Optional[Sequence[float]]
        Sequence of `beta` values swept. Format must be compatible with
        `numpy.array(beta_schedule, dtype=float)`. Values should be non-negative.
    initial_states: Optional[Any]
        One or more samples, each defining an initial state for all the problem
        variables. Initial states are given one per read, but if fewer than additional
        values are generated as specified by `initial_states_generator`. See
        `~dimod.as_samples` for a description of 'samples-like.
    randomize_order: bool
        When `True`, each spin update selects a variable uniformly at random. This
        method is ergodic, obeys detailed balance and preserves symmetries of the model.
        When `False`, updates proceed sequentially through the labeled variables on each
        sweep so that all variables are updated once per sweep. This method:
        * can be non-ergodic in special cases when used with
        `proposal_acceptance_critera=='Metropolis'`.
        * can introduce a dynamical bias as a function of variable order.
        * has faster per spin update than the True method.
    proposal_acceptance_criteria: Literal['Gibbs', 'Metropolis']
        When 'Gibbs', each spin flip proposal is accepted according to the Gibbs
        criteria. When 'Metropolis', each spin flip proposal is accepted according to
        the Metropolis-Hastings criteria.
    """

    num_sweeps_per_beta: int = 1
    seed: Optional[int] = None
    beta_schedule: Optional[Sequence[float]] = None
    initial_states: Optional[Any] = None
    randomize_order: bool = False
    proposal_acceptance_criteria: Literal["Gibbs", "Metropolis"] = "Metropolis"
