from typing import Any, List, Optional, Sequence

from pydantic import Field
from typing_extensions import Literal

from luna_sdk.schemas.solver_parameters.base_parameter import BaseParameter
from luna_sdk.schemas.solver_parameters.dwave import SimulatedAnnealing


class RRSimulatedAnnealing(SimulatedAnnealing):
    """
    Parameters
    ----------
    num_reads: Optional[int]
        Number of reads. Each read is generated by one run of the simulated annealing
        algorithm. If `num_reads` is not explicitly given, it is selected to match the
        number of initial states given. If initial states are not provided, only one
        read is performed.
    num_sweeps: Optional[int]
        Number of sweeps used in annealing.
    beta_range: Union[List[float], Tuple[float, float], NoneType]
        A 2-tuple defining the beginning and end of the beta schedule, where beta is the
        inverse temperature. The schedule is applied linearly in beta. Default range is
        set based on the total bias associated with each node.
    beta_schedule_type: Literal['linear', 'geometric']
        Beta schedule type, or how the beta values are interpolated between the given
        'beta_range'.
    initial_states_generator: Literal['none', 'tile', 'random']
        Defines the expansion of `initial_states` if fewer than `num_reads` are
        specified:
        'none:' if the number of initial states specified is smaller than `num_reads`,
        raises an error.
        'tile': reuses the specified initial states if fewer than `num_reads` or
        truncates if greater.
        'random': expands the specified initial states with randomly generated states if
        fewer than `num_reads` or truncates if greater.
    num_sweeps_per_beta: int
        Number of sweeps to perform at each `beta`. One sweep consists of a sequential
        Metropolis update of all spins.
    beta_schedule: Optional[Sequence[float]]
        Sequence of `beta` values swept. Format must be compatible with
        `numpy.array(beta_schedule, dtype=float)`. Values should be non-negative.
    randomize_order: bool
        When `True`, each spin update selects a variable uniformly at random. This
        method is ergodic, obeys detailed balance and preserves symmetries of the model.
        When `False`, updates proceed sequentially through the labeled variables on each
        sweep so that all variables are updated once per sweep. This method:
        * can be non-ergodic in special cases when used with
        `proposal_acceptance_critera=='Metropolis'`.
        * can introduce a dynamical bias as a function of variable order.
        * has faster per spin update than the True method.
    proposal_acceptance_criteria: Literal['Gibbs', 'Metropolis']
        When 'Gibbs', each spin flip proposal is accepted according to the Gibbs
        criteria. When 'Metropolis', each spin flip proposal is accepted according to
        the Metropolis-Hastings criteria.
    """

    num_sweeps: Optional[int] = None
    num_sweeps_per_beta: int = 1
    beta_schedule: Optional[Sequence[float]] = None
    randomize_order: bool = False
    proposal_acceptance_criteria: Literal["Gibbs", "Metropolis"] = "Metropolis"


class RepeatedReverseSimulatedAnnealingParameters(BaseParameter):
    """
    Parameters for the Repeated Reverse Simulated Annealing solver.

    Parameters
    ----------
    simulated_annealing: RRSimulatedAnnealing
        Simulated Annealing params in each iteration.
    num_reads_per_iter: Optional[List[int]]
        Number of reads in each iteration. Use `num_reads_per_iter[i]` in iteration `i`, and `num_reads_per_iter[-1]` once the list is exhausted. If the parameter is `None`, fall back to `simulated_annealing.num_reads`. Min length: 1.
    initial_states: Optional[Any]
        One or more samples, each defining an initial state for all the problem variables. Initial states are given one per read, but if fewer than additional values are generated as specified by `initial_states_generator`. See `~dimod.as_samples` for a description of 'samples-like.
    timeout: float
        Timeout for the solver.
    max_iter: int
        Maximum number of iterations for the solver.
    target: Optional[Any]
        The target energy for the solver.
    """

    simulated_annealing: RRSimulatedAnnealing = RRSimulatedAnnealing()
    num_reads_per_iter: Optional[List[int]] = Field(default=None, min_length=1)
    initial_states: Optional[Any] = None
    timeout: float = 5.0
    max_iter: int = 10
    target: Optional[Any] = None
