"""
API generator for PyFlow.ts.
"""
import inspect
from pathlib import Path

from ..core import registry

class ApiGenerator:
    """Generate FastAPI endpoints for PyFlow.ts-decorated objects."""

    def __init__(self, output_dir: Path, host: str = "localhost", port: int = 8000, reload: bool = False, debug: bool = False):
        self.host = host
        self.port = port
        self.reload = reload
        self.debug = debug
        self.output_dir = output_dir

    def generate_api_endpoints(self) -> str:
        """Generate FastAPI endpoints for all registered functions and methods."""
        api_template = f'''# Generated by PyFlow.ts - DO NOT EDIT
import inspect
import importlib
import uuid
import json
import traceback
import datetime as dt  # Added for timestamp tracking

from typing import Any, Dict, List, Optional, Union, Type
from fastapi import FastAPI, HTTPException, Body, Request, status
from pydantic import BaseModel, create_model
from pyflow.core import registry

# Instance cache to store object instances
instance_cache = {{}}

# Debugging
DEBUG = {self.debug}

def debug_log(message: str, *args, **kwargs):
    """Print debug message if debug mode is enabled."""
    if DEBUG:
        args_str = ", ".join([str(arg) for arg in args])
        kwargs_str = ", ".join([f"{{k}}={{v}}" for k, v in kwargs.items()])
        all_args = [args_str, kwargs_str]
        all_args_str = ", ".join([a for a in all_args if a])

        if all_args_str:
            print(f"[PyFlow API] {{message}} {{all_args_str}}")
        else:
            print(f"[PyFlow API] {{message}}")

# Enhanced error handling with more detailed error responses
class PyFlowError(Exception):
    """Base class for PyFlow.ts errors with enhanced details."""
    def __init__(self, message: str, status_code: int = 400, details: Dict = None):
        self.message = message
        self.status_code = status_code
        self.details = details or {{}}
        super().__init__(self.message)

    def to_dict(self):
        """Convert error to a dictionary for JSON response."""
        return {{
            "error": self.message,
            "status_code": self.status_code,
            "details": self.details
        }}

# Process arguments that may contain instance references
def process_args(args):
    """Process arguments to handle object instance references."""
    if not args:
        return args

    if isinstance(args, dict):
        result = {{}}
        for key, value in args.items():
            if isinstance(value, dict) and value.get("__object_ref__") and "__instance_id__" in value:
                # This is a reference to a cached instance
                instance_id = value["__instance_id__"]
                if instance_id in instance_cache:
                    result[key] = instance_cache[instance_id]["instance"]
                else:
                    debug_log(f"Warning: Referenced instance ID {{instance_id}} not found in cache")
                    result[key] = None
            elif isinstance(value, dict):
                # Recursively process nested dictionaries
                result[key] = process_args(value)
            elif isinstance(value, list):
                # Recursively process lists
                result[key] = process_args(value)
            else:
                # Pass through other values
                result[key] = value
        return result
    elif isinstance(args, list):
        # Process each item in the list
        return [process_args(item) for item in args]
    else:
        # Return non-dict, non-list values as is
        return args

# Dynamic model generation for function args
def create_request_model(func_name: str, params: Dict[str, Any]) -> Type[BaseModel]:
    """Create a Pydantic model for function parameters."""
    fields = {{}}
    for name, param in params.items():
        if name == 'self':
            continue

        if param.default is inspect.Parameter.empty:
            # Required parameter
            fields[name] = (param.annotation, ...)
        else:
            # Optional parameter with default
            fields[name] = (param.annotation, param.default)

    return create_model(f"{{func_name}}Request", **fields)

# Initialize API router
app = FastAPI(title="PyFlow.ts API", description="Generated API for PyFlow.ts-decorated objects")

# Custom exception handler for PyFlowError
@app.exception_handler(PyFlowError)
async def pyflow_exception_handler(request: Request, exc: PyFlowError):
    from fastapi.responses import JSONResponse
    return JSONResponse(
        status_code=exc.status_code,
        content=exc.to_dict()
    )

@app.post("/api/call-function")
async def call_function(request: Dict[str, Any] = Body(...)):
    """Call a Python function."""
    module_name = request.get("module")
    function_name = request.get("function")
    args = process_args(request.get("args", {{}}))

    debug_log(f"Calling function: {{module_name}}.{{function_name}}", args=args)

    if not module_name or not function_name:
        raise HTTPException(status_code=400, detail="Module and function names are required")

    try:
        # Import the module
        try:
            module = importlib.import_module(module_name)
        except ImportError as e:
            debug_log(f"Import error for module: {{module_name}}")
            raise PyFlowError(
                message=f"Module {{module_name}} not found",
                status_code=status.HTTP_404_NOT_FOUND,
                details={{"error_type": "import_error", "error_msg": str(e)}}
            )

        # Get the function
        func = getattr(module, function_name.split('.')[-1], None)
        if not func or not callable(func):
            # Try to find the function in registry if direct lookup fails
            found = False
            for func_key, func_info in registry.functions.items():
                if func_info['module'] == module_name and function_name.split('.')[-1] == func_info['func'].__name__:
                    func = func_info['func']
                    found = True
                    debug_log(f"Found function in registry: {{func_key}}")
                    break

            if not found:
                # List available functions for debugging
                available_functions = []
                for f_key, f_info in registry.functions.items():
                    if f_info['module'] == module_name:
                        available_functions.append(f_info['func'].__name__)

                raise PyFlowError(
                    message=f"Function {{function_name}} not found in module {{module_name}}",
                    status_code=status.HTTP_404_NOT_FOUND,
                    details={{"available_functions": available_functions}}
                )

        # Call the function with the arguments
        debug_log(f"Executing function with args:", args)
        result = func(**args)
        debug_log(f"Function result:", result)

        # Return the result
        return {{"result": result}}

    except PyFlowError:
        # Re-raise PyFlowError as-is
        raise
    except ImportError as e:
        debug_log(f"Import error for module: {{module_name}}")
        raise HTTPException(status_code=404, detail=f"Module {{module_name}} not found: {{str(e)}}")
    except (TypeError, ValueError) as e:
        debug_log(f"Invalid arguments error:", str(e))
        raise HTTPException(status_code=400, detail=f"Invalid arguments: {{str(e)}}")
    except Exception as e:
        debug_log(f"Error calling function:", str(e), traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Error calling function: {{str(e)}}")

@app.post("/api/create-instance")
async def create_instance(request: Dict[str, Any] = Body(...)):
    """Create a new class instance and return its ID."""
    class_name = request.get("class")
    module_name = request.get("module", "")  # Get optional module name
    constructor_args = process_args(request.get("constructor_args", {{}}))

    if DEBUG:
        print(f"==== CREATE INSTANCE REQUEST ====")
        print(f"Class name: {{class_name}}")
        print(f"Module name: {{module_name}}")
        print(f"Constructor args: {{json.dumps(constructor_args, default=str, indent=2)}}")

    if not class_name:
        raise HTTPException(status_code=400, detail="Class name is required")

    try:
        # Find class using existing methods
        debug_log(f"Creating new instance of class: {{class_name}}")

        # Find the class (using multiple lookup strategies)
        cls = None

        # Try multiple strategies to find the class
        for strategy in ["direct_lookup", "by_short_name", "by_module"]:
            if cls:
                break

            if strategy == "direct_lookup" and class_name in registry.classes:
                cls = registry.classes[class_name]["cls"]
                debug_log(f"Found class by direct lookup: {{class_name}}")

            elif strategy == "by_short_name":
                for registered_name, class_info in registry.classes.items():
                    short_name = registered_name.split('.')[-1]
                    if short_name == class_name:
                        cls = class_info["cls"]
                        debug_log(f"Found class by short name: {{class_name}} (full: {{registered_name}})")
                        break

            elif strategy == "by_module" and "module" in request:
                module_name = request["module"]
                for registered_name, class_info in registry.classes.items():
                    if (class_info.get('module') == module_name and
                        registered_name.endswith(f".{{class_name}}")):
                        cls = class_info["cls"]
                        debug_log(f"Found class by module and name: {{registered_name}}")
                        break

        if not cls:
            available_classes = [f"{{name}} (module: {{info.get('module', 'unknown')}})"
                               for name, info in registry.classes.items()]
            error_msg = f"Class '{{class_name}}' not found in registry. Available: {{', '.join(available_classes)}}"
            debug_log(f"Error: {{error_msg}}")
            raise HTTPException(status_code=404, detail=error_msg)

        # Create instance with constructor args
        try:
            if constructor_args:
                # Filter out any special parameters
                filtered_args = {{k: v for k, v in constructor_args.items() if not k.startswith('__')}}
                debug_log(f"Creating instance with args: {{filtered_args}}")
                instance = cls(**filtered_args)
            else:
                debug_log("Creating instance with no args")
                instance = cls()

            # Generate unique ID and store instance in cache
            instance_id = str(uuid.uuid4())
            instance_cache[instance_id] = {{
                'instance': instance,
                'class_name': class_name,
                'creation_time': dt.datetime.now().isoformat(),
            }}

            debug_log(f"✅ Created instance with ID: {{instance_id}}")
            # Return the instance ID and info
            return {{
                "instance_id": instance_id,
                "class_name": class_name
            }}

        except TypeError as e:
            error_msg = str(e)
            debug_log(f"❌ TypeError during instance creation: {{error_msg}}")
            # Special handling for classes that might need specific args
            if "missing 1 required positional argument:" in error_msg:
                missing_arg = error_msg.split("missing 1 required positional argument: '")[1].split("'")[0]
                debug_log(f"Missing required argument: {{missing_arg}}")
                if missing_arg in constructor_args:
                    debug_log(f"Trying to create with just the required argument: {{missing_arg}}")
                    # Try to create with just the required argument
                    instance = cls(**{{missing_arg: constructor_args[missing_arg]}})

                    # Generate unique ID and store instance
                    instance_id = str(uuid.uuid4())
                    instance_cache[instance_id] = {{
                        'instance': instance,
                        'class_name': class_name,
                        'creation_time': dt.datetime.now().isoformat(),
                    }}

                    debug_log(f"✅ Instance created successfully with {{missing_arg}}")
                    return {{
                        "instance_id": instance_id,
                        "class_name": class_name
                    }}
                else:
                    error_detail = f"Missing required constructor argument: {{missing_arg}}. Provided args: {{list(constructor_args.keys())}}"
                    debug_log(f"❌ {{error_detail}}")
                    raise HTTPException(status_code=400, detail=error_detail)
            else:
                debug_log(f"❌ Invalid constructor args: {{str(e)}}")
                raise HTTPException(status_code=400, detail=f"Invalid constructor args: {{str(e)}}")

    except HTTPException:
        # Re-raise HTTP exceptions as-is
        raise
    except Exception as e:
        import traceback
        debug_log(f"❌ Error creating instance: {{str(e)}}")
        debug_log(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Error creating instance: {{str(e)}}")

@app.post("/api/call-method")
async def call_method(request: Dict[str, Any] = Body(...)):
    """Call a method on a Python class instance."""
    instance_id = request.get("instance_id")
    method_name = request.get("method")
    args = process_args(request.get("args", {{}}))
    constructor_args = process_args(request.get("constructor_args", {{}}))
    class_name = request.get("class")

    # Remove __self__ from args (it's just for TypeScript tracking)
    if "__self__" in args:
        del args["__self__"]

    debug_log(f"Method call request: class={{class_name}}, method={{method_name}}, instance_id={{instance_id}}")
    debug_log(f"Args: {{json.dumps(args, default=str)}}")

    instance = None

    if not instance_id:
        # No instance ID provided, need to create a new instance
        debug_log("No instance ID provided, creating temporary instance")
        if not class_name:
            raise HTTPException(status_code=400, detail="Either instance_id or class name is required")

        # Find the class using same logic as in create_instance
        cls = None

        # Try multiple strategies to find the class
        for strategy in ["direct_lookup", "by_short_name", "by_module"]:
            if cls:
                break

            if strategy == "direct_lookup" and class_name in registry.classes:
                cls = registry.classes[class_name]["cls"]
                debug_log(f"Found class by direct lookup: {{class_name}}")

            elif strategy == "by_short_name":
                for registered_name, class_info in registry.classes.items():
                    short_name = registered_name.split('.')[-1]
                    if short_name == class_name:
                        cls = class_info["cls"]
                        debug_log(f"Found class by short name: {{class_name}} (full: {{registered_name}})")
                        break

            elif strategy == "by_module" and "module" in request:
                module_name = request["module"]
                for registered_name, class_info in registry.classes.items():
                    if (class_info.get('module') == module_name and
                        registered_name.endswith(f".{{class_name}}")):
                        cls = class_info["cls"]
                        debug_log(f"Found class by module and name: {{registered_name}}")
                        break

        if not cls:
            available_classes = [f"{{name}} (module: {{info.get('module', 'unknown')}})"
                               for name, info in registry.classes.items()]
            error_msg = f"Class '{{class_name}}' not found in registry. Available: {{', '.join(available_classes)}}"
            debug_log(f"Error: {{error_msg}}")
            raise HTTPException(status_code=404, detail=error_msg)

        # Create an instance
        try:
            if constructor_args:
                filtered_args = {{k: v for k, v in constructor_args.items() if k != '_module'}}
                debug_log(f"Creating instance with args: {{filtered_args}}")
                instance = cls(**filtered_args)
            else:
                debug_log("Creating instance with no args")
                instance = cls()

            # Store it for future use
            instance_id = str(uuid.uuid4())
            instance_cache[instance_id] = {{
                'instance': instance,
                'class_name': class_name,
                'creation_time': dt.datetime.now().isoformat(),
                'last_accessed': dt.datetime.now().isoformat()
            }}
            debug_log(f"Created temporary instance with ID: {{instance_id}}")

        except Exception as e:
            debug_log(f"Error creating instance: {{str(e)}}")
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=f"Error creating class instance: {{str(e)}}")
    else:
        # Get instance from cache
        debug_log(f"Using cached instance with ID: {{instance_id}}")
        if instance_id not in instance_cache:
            raise HTTPException(status_code=404, detail=f"No instance found with ID {{instance_id}}")

        instance_data = instance_cache[instance_id]
        instance = instance_data['instance']
        class_name = instance_data['class_name']

        # Update last accessed timestamp for tracking
        instance_cache[instance_id]['last_accessed'] = dt.datetime.now().isoformat()

    # Get and call the method
    if not method_name:
        raise HTTPException(status_code=400, detail="Method name is required")

    try:
        debug_log(f"Looking for method '{{method_name}}' in class '{{class_name}}'")
        method = getattr(instance, method_name, None)

        if not method or not callable(method):
            # Check if the method might be from a base class
            cls = type(instance)
            for base in cls.__mro__:
                if method_name in base.__dict__ and callable(base.__dict__[method_name]):
                    method = getattr(instance, method_name)
                    debug_log(f"Found method in base class {{base.__name__}}")
                    break

            if not method or not callable(method):
                # Try one more lookup using dir() which includes inherited methods
                if method_name in dir(instance):
                    method = getattr(instance, method_name)
                    debug_log(f"Found method using dir(): {{method_name}}")
                else:
                    available_methods = [m for m in dir(instance) if callable(getattr(instance, m)) and not m.startswith('__')]
                    error_msg = f"Method {{method_name}} not found in class {{class_name}}. Available: {{', '.join(available_methods)}}"
                    raise HTTPException(status_code=404, detail=error_msg)

        debug_log(f"Calling method {{method_name}} with args: {{args}}")
        result = method(**args)
        debug_log(f"Method result type: {{type(result).__name__}}")

        # Process the result for JSON serialization
        result = process_result_for_serialization(result)

        # Always include the instance_id in the response
        # This is crucial for the client to maintain state across method calls
        return {{
            "result": result,
            "instance_id": instance_id,
            "__instance_id__": instance_id  # Include in both formats for TypeScript client
        }}

    except HTTPException:
        # Re-raise HTTP exceptions as-is
        raise
    except Exception as e:
        debug_log(f"Error calling method: {{str(e)}}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error calling method: {{str(e)}}")

# Add a helper function for result processing
def process_result_for_serialization(result):
    """Process a result object to make it JSON serializable."""
    # Check if it's a list first
    if isinstance(result, list):
        debug_log("Processing list result")
        processed_result = []
        for item in result:
            processed_result.append(process_result_for_serialization(item))
        return processed_result

    # For dictionaries, just return them as they are (they're already serializable)
    elif isinstance(result, dict):
        return result

    # For objects with __dict__ attribute
    elif hasattr(result, '__dict__'):
        debug_log(f"Converting object of type {{type(result).__name__}} to dict")
        try:
            return vars(result)
        except:
            debug_log("Could not convert to dict with vars(), trying __dict__")
            try:
                return result.__dict__
            except:
                debug_log("Could not get __dict__, returning as is")
                return result

    # For objects with to_dict method
    elif hasattr(result, 'to_dict') and callable(getattr(result, 'to_dict')):
        debug_log(f"Using to_dict() method for object of type {{type(result).__name__}}")
        try:
            return result.to_dict()
        except Exception as e:
            debug_log(f"Error calling to_dict(): {{e}}")
            return result

    # Just return other types as they are
    return result

# Add a new endpoint to get instance info for debugging
@app.get("/api/instance/{{instance_id}}")
async def get_instance_info(instance_id: str):
    """Get information about a cached instance."""
    if instance_id not in instance_cache:
        raise HTTPException(status_code=404, detail=f"No instance found with ID {{instance_id}}")

    instance_data = instance_cache[instance_id]
    instance = instance_data['instance']

    # Get public attributes of the instance
    attributes = {{}}
    for key, value in vars(instance).items():
        if not key.startswith('_'):  # Skip private attributes
            try:
                # Try to convert to JSON-serializable form
                json.dumps({{key: value}})
                attributes[key] = value
            except (TypeError, ValueError):
                # If not serializable, just include the type
                attributes[key] = f"<{{type(value).__name__}}>"

    return {{
        "instance_id": instance_id,
        "class_name": instance_data['class_name'],
        "creation_time": instance_data['creation_time'],
        "last_accessed": instance_data.get('last_accessed', 'unknown'),
        "attributes": attributes
    }}

# Add endpoint to list all active instances
@app.get("/api/instances")
async def list_instances():
    """List all active instances in the cache."""
    result = []
    for instance_id, data in instance_cache.items():
        result.append({{
            "instance_id": instance_id,
            "class_name": data['class_name'],
            "creation_time": data.get('creation_time', 'unknown'),
            "last_accessed": data.get('last_accessed', 'unknown')
        }})
    return result

# Additional API endpoints for listing available services
@app.get("/api/services")
async def list_services():
    """List all available services (classes and functions)."""
    services = {{
        "classes": [],
        "functions": []
    }}

    # List all classes
    for class_name, class_info in registry.classes.items():
        cls_data = {{
            "name": class_name,
            "module": class_info.get('module', ''),
            "methods": list(class_info.get('methods', {{}}).keys())
        }}
        services["classes"].append(cls_data)

    # List all functions
    for func_name, func_info in registry.functions.items():
        func_data = {{
            "name": func_name,
            "module": func_info.get('module', '')
        }}
        services["functions"].append(func_data)

    return services

# Register all PyFlow.ts-decorated functions as endpoints
'''

        # Initialize api_code with the template content
        api_code = api_template.replace("{debug}", str(self.debug).lower())

        # Generate explicit endpoints for each registered function
        for func_name, func_info in registry.functions.items():
            if func_name.startswith('_'):
                continue

            func = func_info['func']
            signature = func_info['signature']
            module_name = func_info['module']

            # Add doc string if available
            doc = inspect.getdoc(func) or f"Call {func_name}."

            # Create an endpoint path friendly version of the name
            safe_name = func.__name__.lower().replace(' ', '_')

            api_code += f'''
@app.post("/api/functions/{module_name.replace('.', '/')}/{safe_name}")
async def _{safe_name}_endpoint(request: Dict[str, Any] = Body(...)):
    """{doc}"""
    try:
        debug_log(f"Calling explicit function endpoint: {func_name}")

        # Import the module
        module = importlib.import_module("{module_name}")

        # Get the function
        func = getattr(module, "{func.__name__}")

        # Call the function with the arguments
        debug_log(f"Function args: {{json.dumps(request, default=str)}}")
        result = func(**request)

        # Log and return the result
        debug_log(f"Function returned result of type: {{type(result).__name__}}")
        return {{"result": result}}
    except Exception as e:
        debug_log(f"Error in {safe_name}_endpoint: {{str(e)}}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error calling function: {{str(e)}}")
'''

        # Generate explicit endpoints for each registered class method
        for class_name, class_info in registry.classes.items():
            cls = class_info['cls']
            module_name = class_info['module']

            # Generate a class instantiation endpoint
            safe_class_name = cls.__name__.lower()
            class_doc = inspect.getdoc(cls) or f"{cls.__name__} class"

            api_code += f'''
@app.post("/api/classes/{module_name.replace('.', '/')}/{safe_class_name}")
async def _{safe_class_name}_create_endpoint(request: Dict[str, Any] = Body(...)):
    """{class_doc}

    Creates a new instance of {cls.__name__} with the provided arguments.
    """
    try:
        debug_log(f"Creating {cls.__name__} instance")

        # Import the module and create instance
        module = importlib.import_module("{module_name}")
        cls = getattr(module, "{cls.__name__}")

        # Create the instance with the provided arguments
        instance = cls(**request)

        # Store in cache with a unique ID
        instance_id = str(uuid.uuid4())
        instance_cache[instance_id] = {{
            'instance': instance,
            'class_name': "{cls.__name__}"
        }}

        debug_log(f"Created {cls.__name__} instance with ID: {{instance_id}}")
        return {{
            "instance_id": instance_id,
            "class_name": "{cls.__name__}"
        }}
    except Exception as e:
        debug_log(f"Error creating {cls.__name__} instance: {{str(e)}}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error creating instance: {{str(e)}}")
'''

            for method_name, method_info in class_info['methods'].items():
                if method_name == '__init__':
                    continue

                method = method_info.get('method')
                if not method:
                    continue

                if method_name.startswith('_'):
                    continue

                # Add doc string if available
                method_doc = inspect.getdoc(method) or f"Call {class_name}.{method_name}."

                # Create endpoint-safe names
                safe_method_name = method_name.lower().replace(' ', '_')

                api_code += f'''
@app.post("/api/methods/{module_name.replace('.', '/')}/{safe_class_name}/{safe_method_name}")
async def _{safe_class_name}_{safe_method_name}_endpoint(
    request: Dict[str, Any] = Body(...),
    instance_id: Optional[str] = None
):
    """{method_doc}"""
    try:
        debug_log(f"Calling explicit method endpoint: {class_name}.{method_name}")

        # If instance_id is provided as a query parameter, use it
        # Otherwise check if it's in the request body
        if not instance_id and "instance_id" in request:
            instance_id = request.pop("instance_id")

        # Process based on whether we have an instance_id
        if instance_id:
            # Use existing instance from cache
            if instance_id not in instance_cache:
                raise HTTPException(status_code=404, detail=f"No instance found with ID {{instance_id}}")

            instance = instance_cache[instance_id]["instance"]
            debug_log(f"Using existing instance with ID: {{instance_id}}")
        else:
            # Create a new instance
            debug_log(f"Creating new {cls.__name__} instance")
            constructor_args = request.pop("constructor_args", {{}})

            try:
                # Import module and create instance
                module = importlib.import_module("{module_name}")
                cls = getattr(module, "{cls.__name__}")
                instance = cls(**constructor_args)

                # Store for future use
                instance_id = str(uuid.uuid4())
                instance_cache[instance_id] = {{
                    'instance': instance,
                    'class_name': "{cls.__name__}"
                }}
                debug_log(f"Created instance with ID: {{instance_id}}")
            except Exception as e:
                debug_log(f"Error creating instance: {{str(e)}}")
                raise HTTPException(status_code=400, detail=f"Error creating instance: {{str(e)}}")

        # Call the method with the arguments
        method = getattr(instance, "{method_name}")
        debug_log(f"Calling method with args: {{json.dumps(request, default=str)}}")
        result = method(**request)
        debug_log(f"Method returned result type: {{type(result).__name__}}")

        # Return the result with instance_id for future reference
        return {{"result": result, "instance_id": instance_id}}
    except HTTPException:
        raise
    except Exception as e:
        debug_log(f"Error in {safe_class_name}_{safe_method_name}_endpoint: {{str(e)}}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error calling method: {{str(e)}}")
'''

        # Add CORS handling for browser clients
        api_code += '''
# Add CORS handling for browser access
from fastapi.middleware.cors import CORSMiddleware

# Setup CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins for development
    allow_credentials=True,
    allow_methods=["*"],  # Allow all methods
    allow_headers=["*"],  # Allow all headers
)

# Add index route for API verification
@app.get("/api")
async def api_index():
    """API index endpoint to verify the server is running."""
    return {
        "status": "ok",
        "message": "PyFlow.ts API server is running",
        "version": "1.0.0",
        "services": {
            "classes": len(registry.classes),
            "functions": len(registry.functions)
        }
    }
'''

        return api_code

    def generate_server_app(self) -> str:
        """Generate the server app code that imports API and provides entry point."""
        server_code = f'''# Generated by PyFlow.ts - DO NOT EDIT
import importlib
import sys
from typing import List, Optional
import os
from pathlib import Path

import uvicorn

# Add this directory to path to allow direct execution
current_dir = Path(__file__).parent
sys.path.append(str(current_dir))

# Import the API app
from api import app

def port_in_use(host: str, port: int) -> bool:
    \"\"\"Check if a port is in use.\"\"\"
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex((host, port)) == 0

def start_server(host: str = "{self.host}", port: int = {self.port}, reload: bool = {self.reload}, debug: bool = {self.debug}) -> None:
    \"\"\"Start the API server.\"\"\"
    if debug:
        print(f"Starting server in debug mode on {{host}}:{{port}}")

    # Try to find an available port if the specified one is in use
    if port_in_use(host, port):
        print(f"Warning: Port {{port}} is already in use.")
        for attempt in range(10):  # Try 10 ports starting from the specified one
            new_port = port + attempt + 1
            if not port_in_use(host, new_port):
                print(f"Using alternative port {{new_port}} instead.")
                port = new_port
                break
        else:
            print("Error: Could not find an available port. Please specify a different port using --port.")
            sys.exit(1)

    # Start the uvicorn server with the imported app
    uvicorn.run(
        app,
        host=host,
        port=port,
        reload=reload,
    )

if __name__ == "__main__":
    # Allow command-line parameters when run directly
    import argparse
    parser = argparse.ArgumentParser(description="Start the PyFlow.ts API server")
    parser.add_argument("--host", default="{self.host}", help="Host to bind to")
    parser.add_argument("--port", type=int, default={self.port}, help="Port to bind to")
    parser.add_argument("--reload", action="store_true", help="Enable auto-reload")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    args = parser.parse_args()

    start_server(args.host, args.port, args.reload, args.debug)
'''
        return server_code

    def generate_api(self, create_init: bool = False) -> None:
        """Generate the FastAPI application."""
        # Create the output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Generate and write the API endpoints
        api_code = self.generate_api_endpoints()
        api_file = self.output_dir / "api.py"
        with open(api_file, 'w') as f:
            f.write(api_code)

        # Generate and write the server app
        server_code = self.generate_server_app()
        server_file = self.output_dir / "server.py"
        with open(server_file, 'w') as f:
            f.write(server_code)

        print(f"Generated FastAPI application at {api_file}")
        print(f"Generated server runner at {server_file}")

        # Create an __init__.py to make it a proper package
        if create_init:
            init_file = self.output_dir / "__init__.py"
            with open(init_file, 'w') as f:
                f.write("# Generated by PyFlow.ts\n")

        # Create a main entry point for easier execution
        main_file = self.output_dir / "main.py"
        with open(main_file, 'w') as f:
            f.write("""# Generated by PyFlow.ts - DO NOT EDIT
from .server import start_server

if __name__ == "__main__":
    start_server()
""")
