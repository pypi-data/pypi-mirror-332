# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fdbWbsZgYTqDMrbVlC0MVfjGy8HRutCm
"""

from pandas import read_csv
from pandas import DataFrame
from pandas import concat
import pandas as pd
import numpy as np
import matplotlib.dates as mdates
import matplotlib.colors as mcolors
import matplotlib.pyplot as plt
from .Predictions import individual_model_weekly_count, individual_model_weekly_MAPE
from .Processor import process_metrics_df, find_model_week_values_sum_delay

#generalized version
# def visualize_weekly_case_count_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
#     """
#     Visualizes weekly case counts with predictions for ARIMA and ML models.
#     """
#     # Generate per-model metrics (A_dict, B_dict, etc.)
#     model_dicts = individual_model_weekly_count(WAVES, predictions, delay_list, model_evaluation_dictionary, models, recent_week_count)
#     #print(model_dicts)
#     #model_dicts = {}
#     #for model_name in models.keys():
#         #model_dicts[model_name] = model_results[model_name]

#     max_x_tick = 25  # Maximum number of x-tick labels

#     for WAVE in WAVES:
#         waveID = WAVE.waveID
#         #print("Wave: ", waveID)

#         fig = plt.figure(figsize=(25, 25))
#         gs = fig.add_gridspec(len(predictions) + 1, len(delay_list), hspace=0.2, wspace=0.2)

#         time = WAVE.get_wave_df().tail(recent_week_count).reset_index(drop=False)

#         for delay in delay_list:
#             from_date, to_date = WAVE.get_wave_test_start_date_with_delay(delay)

#             for prediction_length in predictions:
#                 ax = fig.add_subplot(gs[prediction_length, delay])
#                 plt.subplots_adjust(left=0.04, right=0.9, top=0.9, bottom=0.01)

#                 # Plot each model's predictions dynamically

#                 for model_name, model_data in model_dicts.items():
#                     wave_model_data = model_data[waveID][delay]

#                     #print(wave_model_data)
#                     column_name = f"{model_name}_{prediction_length}"
#                     #print('column_name: ', column_name)
#                     #print(wave_model_data.columns)
#                     #print('model_name: ', model_name, 'waveID', waveID, 'delay', delay, 'prediction_length', prediction_length)
#                     if column_name in wave_model_data.columns:

#                         ax.plot(wave_model_data[column_name].dropna(), label=model_name, linewidth=2)

#                 # Scatter plot for observed weekly cases
#                 ax.scatter(time['week'], time['weekcase'], color='black', label='Observed', zorder=3)

#                 # Customize Axes
#                 ax.axvline(x=from_date, color='grey', linestyle="--")
#                 ax.axvline(x=to_date, color='grey', linestyle="--")
#                 if delay == 0:
#                     plt.ylabel(f"Prediction Length = {prediction_length} Week")
#                 if prediction_length == 1:
#                     ax.set_title(f"Delay = {delay} Week")
#                 if prediction_length == 6:
#                     ax.tick_params(axis='x', labelrotation=90)
#                 else:
#                     ax.set_xticklabels([])
#                     ax.set_xticks([])

#         ax.legend(bbox_to_anchor=(-0.5, -0.5), ncol=4, fontsize=20)
#         fig.text(0, 0.5, f'Weekly Case Count, Wave = {waveID}', va='center', rotation='vertical', fontsize="20")
#         plt.show()


def visualize_weekly_case_count_all_model_each_wave(WAVES, predictions, delay_list, delayed_start_matrix, model_evaluation_dictionary, recent_week_count, models):
    """
    Visualizes weekly case counts with predictions for ARIMA and ML models.
    """
    # Generate per-model metrics (A_dict, B_dict, etc.)
    model_dicts = individual_model_weekly_count(WAVES, predictions, delay_list, model_evaluation_dictionary, models, recent_week_count)
    print(model_dicts)
    #model_dicts = {}
    #for model_name in models.keys():
        #model_dicts[model_name] = model_results[model_name]

    max_x_tick = 25  # Maximum number of x-tick labels

    for WAVE in WAVES:
        waveID = WAVE.waveID
        #print("Wave: ", waveID)

        fig = plt.figure(figsize=(25, 25))
        gs = fig.add_gridspec(len(predictions) + 1, len(delay_list), hspace=0.2, wspace=0.2)

        time = WAVE.get_wave_df().tail(recent_week_count).reset_index(drop=False)

        for delay in delay_list:
            from_date, to_date = WAVE.get_wave_test_start_date_with_delay(delay)
            delayed_wave, _, _ = WAVE.get_wave_dates_with_delay_delay(delay, delayed_start_matrix)
            time = delayed_wave.tail(recent_week_count).reset_index(drop=False)
            print("Wave: ", waveID, "Delay: ", delay, 'from: ', from_date, to_date)
            for prediction_length in predictions:
                ax = fig.add_subplot(gs[prediction_length, delay])
                plt.subplots_adjust(left=0.04, right=0.9, top=0.9, bottom=0.01)

                # Plot each model's predictions dynamically

                for model_name, model_data in model_dicts.items():
                    wave_model_data = model_data[waveID][delay]

                    #print(f"{model_name}: {wave_model_data}")
                    column_name = f"{model_name}_{prediction_length}"
                    #print('column_name: ', column_name)
                    #print(wave_model_data[column_name].dropna())
                    #print(wave_model_data.columns)
                    #print('model_name: ', model_name, 'waveID', waveID, 'delay', delay, 'prediction_length', prediction_length)
                    if column_name in wave_model_data.columns:
                        ax.plot(wave_model_data[column_name].dropna(), label=model_name, linewidth=2)

                # Scatter plot for observed weekly cases
                #print('time[week]', time['week'])
                ax.scatter(time['week'], time['weekcase'], color='black', label='Observed', zorder=3)

                # Customize Axes
                ax.axvline(x=from_date, color='grey', linestyle="--")
                ax.axvline(x=to_date, color='grey', linestyle="--")
                if delay == 0:
                    plt.ylabel(f"Prediction Length = {prediction_length} Week")
                if prediction_length == 1:
                    ax.set_title(f"Delay = {delay} Week")
                if prediction_length == 6:
                    ax.tick_params(axis='x', labelrotation=90)
                else:
                    ax.set_xticklabels([])
                    ax.set_xticks([])

        ax.legend(bbox_to_anchor=(-0.5, -0.5), ncol=4, fontsize=20)
        fig.text(0, 0.5, f'Weekly Case Count, Wave = {waveID}', va='center', rotation='vertical', fontsize="20")
        plt.show()



#generalized

from matplotlib.colors import ListedColormap
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# def visualize_weekly_MAPE_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
#     """
#     Generalized function to visualize weekly MAPE for multiple models across waves.

#     Parameters:
#         WAVES: List of wave objects containing wave IDs.
#         predictions: Model predictions.
#         delay_list: List of delays for predictions.
#         model_evaluation_dictionary: Dictionary of evaluation results.
#         recent_week_count: Number of recent weeks to consider.
#         models: Dictionary of models to visualize with their keys and associated methods (e.g., {'ARIMA': SARIMAX, 'RF': RandomForestRegressor}).
#     """
#     model_results_wave_collection = individual_model_weekly_MAPE(WAVES, predictions, delay_list, model_evaluation_dictionary, models)
#     mape_wave_delay = {}
#     print('individual_model_weekly_MAPE DONE')
#     for WAVE in WAVES:  # Iterate over each wave
#         waveID = WAVE.waveID
#         fig, axes = plt.subplots(len(models), len(delay_list), sharex=True, sharey=True, figsize=(25, 10))
#         gs = fig.add_gridspec(len(models), len(delay_list), hspace=0.2, wspace=0.2)
#         plt.subplots_adjust(left=0.08, right=0.9, top=0.9, bottom=0.1)

#         for model_index, (model_name, model_class) in enumerate(models.items()):  # Dynamically iterate over models
#             model_results_collection = model_results_wave_collection[model_name][waveID]

#             for delay in delay_list:  # Iterate over delays
#                 ax = axes[model_index, delay]
#                 mape_delay = pd.DataFrame()
#                 weeks = [x - 1 for x in predictions]
#                 print(weeks)
#                 # Retrieve and plot model results
#                 all_week_list, values_list = find_model_week_values_sum_delay(model_results_collection, delay, weeks)
#                 values_df = pd.DataFrame(values_list)
#                 values_df.columns = [model_name]
#                 #print('okk')
#                 # Bar and line plot
#                 all_week_list.plot(
#                     kind='bar',
#                     stacked=False,
#                     width=1,
#                     colormap=ListedColormap(sns.color_palette("muted", 10)),
#                     figsize=(13, 15),
#                     ax=ax
#                 )
#                 ax.plot(values_list, label="MAPE", marker='o')  # Line plot with markers
#                 ax.scatter(range(len(values_list)), values_list, color='red', label="MAPE Points", zorder=3)  # Scatter plot for individual points

#                 ax.set_title(f"Delay = {delay} Week ")
#                 ax.get_legend().remove()

#                 mape_delay = pd.concat([mape_delay, values_df], axis=1, join='inner')  # Concatenate MAPE results
#                 mape_wave_delay[waveID] = mape_delay

#                 # Labeling
#                 if delay == 0:
#                     ax.set_ylabel(model_name)
#                 if delay == len(delay_list) - 1 and model_index == len(models) - 1:
#                     ax.legend(
#                         ["MAPE", 'First Week', 'Second Week', 'Third Week', 'Fourth Week', 'Fifth Week', 'Sixth Week'],
#                         loc='lower center',
#                         bbox_to_anchor=(-2, -0.3),
#                         ncol=7
#                     )

#         # Super labels
#         fig.supxlabel(f"Prediction Length (Week), Wave = {waveID}")
#         fig.supylabel("MAPE %")

#     return mape_wave_delay


def visualize_weekly_MAPE_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
    """
    Generalized function to visualize weekly MAPE for multiple models across waves.

    Parameters:
        WAVES: List of wave objects containing wave IDs.
        predictions: Model predictions.
        delay_list: List of delays for predictions.
        model_evaluation_dictionary: Dictionary of evaluation results.
        recent_week_count: Number of recent weeks to consider.
        models: Dictionary of models to visualize with their keys and associated methods (e.g., {'ARIMA': SARIMAX, 'RF': RandomForestRegressor}).
    """
    model_results_wave_collection = individual_model_weekly_MAPE(WAVES, predictions, delay_list, model_evaluation_dictionary, models)
    mape_wave_delay = {}
    print('individual_model_weekly_MAPE DONE')
    for WAVE in WAVES:  # Iterate over each wave
        waveID = WAVE.waveID
        fig, axes = plt.subplots(len(models), len(delay_list), sharex=True, sharey=True, figsize=(25, 10))
        gs = fig.add_gridspec(len(models), len(delay_list), hspace=0.2, wspace=0.2)
        plt.subplots_adjust(left=0.08, right=0.9, top=0.9, bottom=0.1)

        for model_index, (model_name, model_class) in enumerate(models.items()):  # Dynamically iterate over models
            model_results_collection = model_results_wave_collection[model_name][waveID]

            for delay in delay_list:  # Iterate over delays
                ax = axes[model_index, delay]
                mape_delay = pd.DataFrame()
                weeks = [x - 1 for x in predictions]
                #print('model_results_collection', model_results_collection)
                # Retrieve and plot model results
                all_week_list, values_list = find_model_week_values_sum_delay(model_results_collection, delay, weeks)
                values_df = pd.DataFrame(values_list)
                values_df.columns = [model_name]
                #print('okk')
                # Bar and line plot
                all_week_list.plot(
                    kind='bar',
                    stacked=False,
                    width=1,
                    colormap=ListedColormap(sns.color_palette("muted", 10)),
                    figsize=(13, 15),
                    ax=ax
                )
                #ax.plot(values_list, label="MAPE")
                ax.plot(values_list, label="MAPE", marker='o')  # Line plot with markers
                ax.scatter(range(len(values_list)), values_list, color='red', label="MAPE Points", zorder=3)  # Scatter plot for individual points

                ax.set_title(f"Delay = {delay} Week ")
                ax.get_legend().remove()

                mape_delay = pd.concat([mape_delay, values_df], axis=1, join='inner')  # Concatenate MAPE results
                mape_wave_delay[waveID] = mape_delay
                #print('waveID ', waveID, 'delay', delay)#, 'mape_delay', mape_delay)
                # Labeling
                if delay == 0:
                    ax.set_ylabel(model_name)
                if delay == len(delay_list) - 1 and model_index == len(models) - 1:
                    ax.legend(
                        ["MAPE", 'First Week', 'Second Week', 'Third Week', 'Fourth Week', 'Fifth Week', 'Sixth Week'],
                        loc='lower center',
                        bbox_to_anchor=(-2, -0.3),
                        ncol=7
                    )

        # Super labels
        fig.supxlabel(f"Prediction Length (Week), Wave = {waveID}")
        fig.supylabel("MAPE %")

    return mape_wave_delay



import matplotlib.pyplot as plt
import datetime
#Visualization.py
def visualize_wave_delays(data_dict):
    """
    Plots clearer and user-friendly time interval ranges for all wave-delay combinations.

    Args:
        data_dict (dict): A dictionary containing wave delay combinations
                          with 'all', 'train', and 'test' data ranges.
    """
    plt.figure(figsize=(14, 8))
    plt.title("Time Interval Comparison for Wave-Delay Combinations", fontsize=16, pad=20)
    plt.xlabel("Date", fontsize=14, labelpad=40)  # Move x-axis label down
    plt.ylabel("Wave-Delay Combinations", fontsize=14, labelpad=15)  # Move y-axis label up

    # Move y-axis label farther to the right
    plt.gca().yaxis.set_label_coords(-0.1, 0.5)  # Adjust x and y positions of label


    y_offset = 1  # Start y_offset for waves
    spacing = 2  # Spacing between each wave

    for wave_name, intervals in data_dict.items():
        # Extract ranges and convert to datetime
        all_range = [datetime.datetime.fromisoformat(i) for i in intervals['all'].index]
        train_range = [datetime.datetime.fromisoformat(i) for i in intervals['train'].index]
        test_range = [datetime.datetime.fromisoformat(i) for i in intervals['test'].index]

        # Plot 'all', 'train', and 'test' ranges with spacing
        plt.hlines(y=y_offset, xmin=all_range[0], xmax=all_range[-1], color='gray', label='Full Range' if y_offset == 1 else "", linewidth=2, alpha=0.7)
        plt.hlines(y=y_offset + 0.5, xmin=train_range[0], xmax=train_range[-1], color='blue', label='Train Range' if y_offset == 1 else "", linewidth=2)
        plt.hlines(y=y_offset + 1, xmin=test_range[0], xmax=test_range[-1], color='green', label='Test Range' if y_offset == 1 else "", linewidth=2)

        # Add markers for start and end dates
        plt.scatter([all_range[0], all_range[-1]], [y_offset, y_offset], color='gray', edgecolor='black', s=40, label='_nolegend_')
        plt.scatter([train_range[0], train_range[-1]], [y_offset + 0.5, y_offset + 0.5], color='blue', edgecolor='black', s=40, label='_nolegend_')
        plt.scatter([test_range[0], test_range[-1]], [y_offset + 1, y_offset + 1], color='green', edgecolor='black', s=40, label='_nolegend_')

        # Annotate wave name slightly to the left
        plt.text(all_range[0] - datetime.timedelta(days=7), y_offset - 0.2, wave_name, fontsize=12, ha='right', color='black')

        # Increment y_offset for the next wave
        y_offset += spacing

    # Adjust y-axis limits
    plt.ylim(0, y_offset)
    plt.yticks([])  # Remove y-axis ticks for a cleaner look
    plt.xticks(rotation=45, fontsize=12)

    # Add a grouped legend
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15), fontsize=12, ncol=3, frameon=False)

    # Final layout adjustments
    plt.tight_layout()
    plt.show()





#generalized

def plot_predictions(wave_tasks, labels, delay, prediction_length, MAPE_data_dictionary, models, observed_label='Observed', recent_week_count=None):
    """
    Generalized function to plot predictions for multiple ML models and ARIMA.

    Parameters:
    - wave_tasks: List of wave task objects
    - delay: Delay parameter
    - prediction_length: Prediction length parameter
    - MAPE_data_dictionary: Dictionary containing MAPE data for each wave, delay, and prediction length
    - models: Dictionary of models to include in the plot
    - observed_label: Column name for the observed data
    - recent_week_count: Optional. Number of weeks to consider for plotting. Defaults to None (all data).
    """
    fig = plt.figure(figsize=(16, 10))
    plt.subplots_adjust(left=0.1, right=1, top=1, bottom=0.15)
    gs = fig.add_gridspec(len(wave_tasks), 1, hspace=0, wspace=0)
    i = 0

    #labels = ['', " & 2", " & 2 & 1"]  # Example labels for waves
    for wave in wave_tasks:
        waveID = wave.waveID
        wave_delay_prediction_length_key = f'wave {waveID} delay {delay} prediction_length {prediction_length}'
        task = MAPE_data_dictionary[wave_delay_prediction_length_key]

        # Extract recent weeks if specified
        if recent_week_count:
            task = task.tail(recent_week_count).reset_index(drop=True)

        ax = fig.add_subplot(gs[i, 0])

        # Plot each model's predictions
        for model_name in models.keys():
            if model_name in task.columns:
                ax.plot(task.index, task[model_name], label=model_name, linestyle='-', lw=1.5)

        # Plot observed data
        if observed_label in task.columns:
            ax.plot(task.index, task[observed_label], label=observed_label, color='black', linestyle='dotted')

        ax.set_ylabel("Wave "+labels[i], fontsize=13)

        i += 1
        if i >= 2:
            ax.legend(loc='lower center', bbox_to_anchor=(1.05, 1), ncol=1)
            ax.set_xticklabels(task.index, rotation=45)

        ax.axvline('2023-10-08', color='black', linestyle='--', lw=2)  # Example date for a vertical line

    # Adding title and labels
    fig.supxlabel('Week', fontsize=16)
    fig.supylabel("Covid Cases", fontsize=16)
    plt.show()