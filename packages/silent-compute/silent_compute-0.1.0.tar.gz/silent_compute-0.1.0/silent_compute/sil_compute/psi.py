import ctypes
from ctypes import c_char_p, c_size_t, c_uint64, POINTER, byref, c_bool, c_int
import time

lib = None

def load_shared_library(shared_lib):
    """Initializes the shared library for the PSC protocol."""
    global lib
    lib = shared_lib

    # Define argument and return types for Rust functions
    
    # get_seed: No arguments, returns a random seed (u64)
    lib.get_seed.restype = c_uint64

    # generate_session_id_with_seed: Generates a session ID from a seed
    lib.generate_session_id_with_seed.argtypes = [c_uint64, POINTER(ctypes.c_uint8 * 32)]
    lib.generate_session_id_with_seed.restype = None

    # generate_hash: Creates a hash from CSV input, number of entries, and a type flag
    lib.generate_hash.argtypes = [c_char_p, c_size_t, c_char_p]
    lib.generate_hash.restype = POINTER(ctypes.c_uint8)

    # create_psc_msg1: Generates PSC message 1 with session ID, customer hash, and RNG seed
    lib.create_psc_msg1.argtypes = [
        POINTER(ctypes.c_uint8 * 32),  # session ID
        POINTER(ctypes.c_uint8 * 32),  # customer hash
        c_uint64,                      # RNG seed
        POINTER(ctypes.c_uint8),       # output state buffer
        POINTER(c_size_t),             # output state length
        POINTER(ctypes.c_uint8),       # output msg1 buffer
        POINTER(c_size_t)              # output msg1 length
    ]
    lib.create_psc_msg1.restype = c_bool

    # process_psc_msg1: Processes PSC message 1 and generates message 2
    lib.process_psc_msg1.argtypes = [
        POINTER(ctypes.c_uint8 * 32),  # session ID
        POINTER(ctypes.c_uint8),       # big_y_bytes pointer
        c_size_t,                      # number of entries in big_y_bytes
        POINTER(ctypes.c_uint8),       # msg1 pointer
        c_size_t,                      # msg1 length
        c_uint64,                      # RNG seed
        POINTER(POINTER(ctypes.c_uint8)),  # output_msg2_ptr
        POINTER(c_size_t)              # output msg2 length
    ]
    lib.process_psc_msg1.restype = c_int

    # process_psc_msg2: Finalizes the PSC protocol by processing message 2
    lib.process_psc_msg2.argtypes = [
        POINTER(ctypes.c_uint8),  # state_ptr
        c_size_t,                 # state_len
        POINTER(ctypes.c_uint8),  # msg2_ptr
        c_size_t,                 # msg2_len
        POINTER(c_bool)           # result_ptr
    ]
    lib.process_psc_msg2.restype = c_int


# Function to get a random seed
def get_seed() -> int:
    """Returns a random seed generated by the Rust library."""
    return lib.get_seed()

# Function to generate a session ID given a seed
def generate_session_id(seed: int) -> bytes:
    """Generates a 32-byte session ID using a provided seed."""
    session_id_array = (ctypes.c_uint8 * 32)()
    lib.generate_session_id_with_seed(seed, byref(session_id_array))
    return bytes(session_id_array)

# Function to generate hash bytes for either a single customer or a sanction list
def generate_hash(input_data: str, num_entries: int, type_flag: str) -> bytes:
    """Generates hash bytes from CSV input, supporting single customer or sanction list modes."""
    input_data_c = c_char_p(input_data.encode('utf-8'))
    type_flag_c = c_char_p(type_flag.encode('utf-8'))
    hash_ptr = lib.generate_hash(input_data_c, num_entries, type_flag_c)
    if not hash_ptr:
        raise ValueError("Failed to generate hash bytes")
    hash_length = 32 * num_entries
    hash_bytes = bytes(hash_ptr[i] for i in range(hash_length))
    return hash_bytes

# Function to create PSC message 1
def create_psc_msg1(session_id: bytes, customer_hash: bytes, seed: int) :
    """Creates PSC message 1 using session ID, customer hash, and a random seed."""
    if len(session_id) != 32 or len(customer_hash) != 32:
        raise ValueError("Session ID and customer hash must each be 32 bytes long")
    session_id_array = (ctypes.c_uint8 * 32).from_buffer_copy(session_id)
    customer_hash_array = (ctypes.c_uint8 * 32).from_buffer_copy(customer_hash)
    output_state_len = c_size_t(0)
    output_msg1_len = c_size_t(0)
    output_state_buf = (ctypes.c_uint8 * 256)()
    output_msg1_buf = (ctypes.c_uint8 * 256)()
    success = lib.create_psc_msg1(
        byref(session_id_array),
        byref(customer_hash_array),
        seed,
        output_state_buf,
        byref(output_state_len),
        output_msg1_buf,
        byref(output_msg1_len)
    )
    if not success:
        raise ValueError("Failed to create PSC message 1")
    state_bytes = bytes(output_state_buf[:output_state_len.value])
    msg1_bytes = bytes(output_msg1_buf[:output_msg1_len.value])
    return state_bytes, msg1_bytes

# Function to process PSC message 1
def process_psc_msg1(session_id: bytes, big_y_hashes: list, msg1: bytes, seed: int) -> bytes:
    """Processes PSC message 1 and generates the next protocol message."""
    if len(session_id) != 32:
        raise ValueError("Session ID must be 32 bytes long")
    session_id_array = (ctypes.c_uint8 * 32).from_buffer_copy(session_id)
    msg1_array = (ctypes.c_uint8 * len(msg1)).from_buffer_copy(msg1)
    big_y_bytes = (ctypes.c_uint8 * (32 * len(big_y_hashes)))()
    for i, customer_hash in enumerate(big_y_hashes):
        for j in range(32):
            big_y_bytes[i * 32 + j] = customer_hash[j]
    output_msg2_ptr = POINTER(ctypes.c_uint8)()
    output_msg2_len = c_size_t(0)
    result = lib.process_psc_msg1(
        byref(session_id_array),
        big_y_bytes,
        len(big_y_hashes),
        msg1_array,
        len(msg1),
        seed,
        byref(output_msg2_ptr),
        byref(output_msg2_len)
    )
    if result == 0:
        msg2 = bytes(ctypes.cast(output_msg2_ptr, POINTER(ctypes.c_uint8 * output_msg2_len.value)).contents)
        return msg2
    else:
        raise ValueError(f"Error processing PSC message 1, code {result}")


def process_psc_msg2(state: bytes, msg2: bytes) -> int:
    """Processes PSC message 2 and returns the ret_code."""
    # Convert input data to ctypes pointers
    state_ptr = (ctypes.c_uint8 * len(state)).from_buffer_copy(state)
    msg2_ptr = (ctypes.c_uint8 * len(msg2)).from_buffer_copy(msg2)

    # Allocate a c_bool variable to hold the result from Rust
    result = c_bool(False)

    # Call the Rust function and return the ret_code
    ret_code = lib.process_psc_msg2(
        state_ptr,    # state_ptr
        len(state),    # state_len
        msg2_ptr,     # msg2_ptr
        len(msg2),     # msg2_len
        byref(result)  # result_ptr
    )
    return ret_code, result