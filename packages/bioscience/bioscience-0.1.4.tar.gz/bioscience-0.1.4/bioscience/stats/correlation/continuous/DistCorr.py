from bioscience.base import *

import math
import sys
import os
import threading
import warnings
import numpy as np
import time

def distcorr(dataset, deviceCount = 0, mode = 1, debug = False):
    """
    Application of the Distance Correlation (distcorr) method
    
    :param dataset: The dataset object to be binarized.
    :type dataset: :class:`bioscience.base.models.Dataset`
    
    param deviceCount: Number of GPU devices to execute
    :type deviceCount: int
    
    :param mode: Type of execution of the algorithm: `mode=1` for sequential execution, `mode=2` for parallel execution on CPUs and `mode=3` for execution on a multi-GPU architecture.
    :type mode: int
    
    :return: A CorrelationModel object that stores values generated by a correlation method.
    :rtype: :class:`bioscience.base.models.CorrelationModel`      
    """

    oModel = None
    if (dataset is not None):
        sMode = ""
        if mode == 2: # NUMBA: CPU Parallel mode
            # To be developed
            sMode = "NUMBA - CPU Parallel mode (to be developed)"
        elif mode == 3: # NUMBA: GPU Parallel mode
            # To be developed
            sMode = "NUMBA - GPU Parallel mode (to be developed)"
        else: # Sequential mode
            oModel = __distcorrSequential(dataset, debug)
            deviceCount = 0
            sMode = "CPU Sequential"
    
    return oModel

def __distcorrSequential(dataset, debug):
    iRows = dataset.data.shape[0]
    iCols = dataset.data.shape[1]
    fExecutionTime = None
    
    maxPairs = 0        
    for i in range(iRows):
        for j in range(i + 1, iRows):
            maxPairs += 1
    
    resultsCorrelation = np.zeros(maxPairs)    
    
    if debug == True:
        start_time = time.time()
        
    for pattern, value in enumerate(resultsCorrelation):
        
        # Get R1 and R2 from index results vector
        r1 = 0
        r2 = -1
        auxPat = pattern - iRows + 1
        
        if auxPat < 0:
            r2 = auxPat + iRows

        j = iRows - 2
        while r2 == -1:
            auxPat -= j
            r1 += 1
            if auxPat < 0:
                r2 = (j + auxPat) + (r1 + 1)
            j -= 1
        
        if r1 < iRows and r2 < iRows:
            
            # Calculate distance matrix
            distR1 = np.zeros((iCols,iCols))
            distR2 = np.zeros((iCols,iCols))
            
            for i in range(iCols):
                for j in range(iCols):
                    distR1[i, j] = abs(dataset.data[r1][i] - dataset.data[r1][j])
                    distR2[i, j] = abs(dataset.data[r2][i] - dataset.data[r2][j])
            
            # Centering distance matrix
            centerR1 = np.zeros((iCols, iCols))
            centerR2 = np.zeros((iCols, iCols))
            
            rowMeanR1 = np.zeros(iCols)
            colMeanR1 = np.zeros(iCols)
            overallMeanR1 = 0
            
            rowMeanR2 = np.zeros(iCols)
            colMeanR2 = np.zeros(iCols)
            overallMeanR2 = 0
            
            for i in range(iCols):
                rowMeanR1[i] = np.sum(distR1[i, :]) / iCols
                colMeanR1[i] = np.sum(distR1[:, i]) / iCols
                rowMeanR2[i] = np.sum(distR2[i, :]) / iCols
                colMeanR2[i] = np.sum(distR2[:, i]) / iCols
            
            overallMeanR1 = np.sum(distR1) / (iCols * iCols)
            overallMeanR2 = np.sum(distR2) / (iCols * iCols)
            
            for i in range(iCols):
                for j in range(iCols):
                    centerR1[i, j] = distR1[i, j] - rowMeanR1[i] - colMeanR1[j] + overallMeanR1
                    centerR2[i, j] = distR2[i, j] - rowMeanR2[i] - colMeanR2[j] + overallMeanR2
            
            # Means
            meanR1R2 = np.sum(centerR1*centerR2) / (iCols*iCols)
            meanR1sq = np.sum(centerR1*centerR1) / (iCols*iCols)
            meanR2sq = np.sum(centerR2*centerR2) / (iCols*iCols)
            
            # Calculate distance correlation
            dVarR1 = np.sqrt(meanR1sq)
            dVarR2 = np.sqrt(meanR2sq)           
            denom = np.sqrt(dVarR1 * dVarR2)
            if denom != 0:
                distCorrValue = np.sqrt(meanR1R2) / np.sqrt(dVarR1 * dVarR2)
            else:
                distCorrValue = None
        
            resultsCorrelation[pattern] = distCorrValue
    
    if debug == True:
        end_time = time.time()
        fExecutionTime = end_time - start_time
    
    oCorrelationResults = CorrelationModel(name=DISTCORR, results=resultsCorrelation, rows = iRows, executionTime=fExecutionTime)
    return oCorrelationResults