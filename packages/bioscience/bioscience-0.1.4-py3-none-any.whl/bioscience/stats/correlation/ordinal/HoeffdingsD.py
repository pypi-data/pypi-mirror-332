from bioscience.base import *

import math
import sys
import os
import threading
import warnings
import numpy as np
import time

def hoeffdingsD(dataset, deviceCount = 0, mode = 1, debug = False):
    """
    Application of the Hoeffding's D correlation method. A Hoeffdings'D value of 0 indicates a clear independence between variables; whereas, a value of 1 indicates a perfect dependence between variables. A negative value close to -1 may indicate a very strong dependence between the variables, in the opposite direction to independence.
    
    :param dataset: The dataset object to be binarized.
    :type dataset: :class:`bioscience.base.models.Dataset`
    
    param deviceCount: Number of GPU devices to execute
    :type deviceCount: int
    
    :param mode: Type of execution of the algorithm: `mode=1` for sequential execution, `mode=2` for parallel execution on CPUs and `mode=3` for execution on a multi-GPU architecture.
    :type mode: int
    
    :return: A CorrelationModel object that stores values generated by a correlation method.
    :rtype: :class:`bioscience.base.models.CorrelationModel`      
    """
    
    oModel = None
    if (dataset is not None):
        sMode = ""
        if mode == 2: # NUMBA: CPU Parallel mode
            # To be developed
            sMode = "NUMBA - CPU Parallel mode (to be developed)"
        elif mode == 3: # NUMBA: GPU Parallel mode
            # To be developed
            sMode = "NUMBA - GPU Parallel mode (to be developed)"
        else: # Sequential mode
            oModel = __hoeffdingsDSequential(dataset, debug)
            deviceCount = 0
            sMode = "CPU Sequential"
    
    return oModel

def __hoeffdingsDSequential(dataset, debug):
    iRows = dataset.data.shape[0]
    iCols = dataset.data.shape[1]
    fExecutionTime = None
    
    maxPairs = 0        
    for i in range(iRows):
        for j in range(i + 1, iRows):
            maxPairs += 1
    
    resultsCorrelation = np.zeros(maxPairs)    
    
    if debug == True:
        start_time = time.time()
        
    for pattern, value in enumerate(resultsCorrelation):
        
        # Get R1 and R2 from index results vector
        r1 = 0
        r2 = -1
        auxPat = pattern - iRows + 1
        
        if auxPat < 0:
            r2 = auxPat + iRows

        j = iRows - 2
        while r2 == -1:
            auxPat -= j
            r1 += 1
            if auxPat < 0:
                r2 = (j + auxPat) + (r1 + 1)
            j -= 1
        
        if r1 < iRows and r2 < iRows:            
            
            lenRow = dataset.data[r1].shape[0]            
            R=__rankdata(dataset.data[r1])
            S=__rankdata(dataset.data[r2])            
            Q=np.zeros(lenRow)
            for i in range(0, lenRow):
                Q[i] = 1 + np.sum(np.bitwise_and(R<R[i] ,S<S[i]))
                Q[i] = Q[i] + 1/4 * (np.sum(np.bitwise_and(np.isin(R,R[i]),np.isin(S,S[i])))-1)
                Q[i] = Q[i] + 1/2 * (np.sum(np.bitwise_and(np.isin(R,R[i]),S<S[i])))
                Q[i] = Q[i] + 1/2 * (np.sum(np.bitwise_and(R<R[i],np.isin(S,S[i]))))
            D1 = np.sum( np.multiply((Q-1),(Q-2)) )
            D2 = np.sum( np.multiply(np.multiply((R-1),(R-2)),np.multiply((S-1),(S-2)) ) )
            D3 = np.sum( np.multiply(np.multiply((R-2),(S-2)),(Q-1)) )
            if (lenRow*(lenRow-1)*(lenRow-2)*(lenRow-3)*(lenRow-4)) == 0:
                dValue = None
            else:
                dValue = 30*((lenRow-2)*(lenRow-3)*D1 + D2 - 2*(lenRow-2)*D3) / (lenRow*(lenRow-1)*(lenRow-2)*(lenRow-3)*(lenRow-4))
        
            resultsCorrelation[pattern] = dValue
    
    if debug == True:
        end_time = time.time()
        fExecutionTime = end_time - start_time
    
    oCorrelationResults = CorrelationModel(name=HOEFFDINGS, results=resultsCorrelation, rows = iRows, executionTime=fExecutionTime)
    return oCorrelationResults

def __rankdata(a):
    n = len(a)
    ivec = np.argsort(a)
    svec = np.take(a, ivec)
    sumranks = 0
    dupcount = 0
    ranks = np.zeros(n)
    
    for i in range(n):
        sumranks += i
        dupcount += 1
        if i == n - 1 or svec[i] != svec[i + 1]:
            avg_rank = sumranks / float(dupcount) + 1
            for j in range(i - dupcount + 1, i + 1):
                ranks[ivec[j]] = avg_rank
            sumranks = 0
            dupcount = 0
    
    return ranks