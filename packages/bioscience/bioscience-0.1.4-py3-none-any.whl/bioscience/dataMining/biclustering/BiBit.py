from bioscience.base import *
from numba.core.errors import NumbaDeprecationWarning, NumbaPendingDeprecationWarning

import warnings
import numpy as np
import platform
import time
import queue

import sys
import os
import threading
import warnings
from numba import cuda, njit, NumbaWarning, set_num_threads, prange

def processBiBit(dataset, cMnr, cMnc, deviceCount, mode, debug):
    
    """
    Sub-function processing the BiBit Biclustering algorithm.
    
    :param dataset: The dataset object store the data of input file.
    :type dataset: :class:`bioscience.base.models.Dataset`
    
    :param cMnr: Minimum number of rows to build a valid bicluster.
    :type cMnr: int
    
    :param cMnc: Minimum number of columns to build a valid bicluster.
    :type cMnc: int
    
    :param deviceCount: Number of GPU devices to execute
    :type deviceCount: int
    
    :param mode: Type of execution of the algorithm: `mode=1` for sequential execution, `mode=2` for parallel execution on CPUs and `mode=3` for execution on a multi-GPU architecture.
    :type mode: int
    
    :param mode: Attribute used to run the algorithm in debug mode.
    :type mode: boolean
    
    :return: A BiclusteringModel object that stores all biclusters generated by the BiBit algorithm.
    :rtype: :class:`bioscience.base.models.BiclusteringModel`       
    """
    
    # Matrix reduce
    dataset.data = __matrixReduce(dataset.data)
    global maxPatterns
    maxPatterns = 0
    for i in range(dataset.data.shape[0]):
        for j in range(i + 1, dataset.data.shape[0]):
            maxPatterns += 1
    
    sMode = ""
    if mode == 2: # NUMBA: CPU Parallel mode
        oModel = __bibitNumbaCpu(dataset, cMnr, cMnc, debug)     
        sMode = "NUMBA - CPU Parallel mode"
    elif mode == 3: # NUMBA: GPU Parallel mode
        oModel = __bibitNumbaGpu(dataset, cMnr, cMnc, deviceCount, debug)  
        sMode = "NUMBA - GPU Parallel mode"
    else: # Sequential mode
        oModel = __bibitSequential(dataset, cMnr, cMnc, debug)
        deviceCount = 0  
        sMode = "CPU Sequential"        
    if debug == False:
        __fillDataBiclusters(dataset, oModel)
    
    print("Resume:\n========================")
    print("Dataset size (rows,columns): ",dataset.original.shape[0],",",dataset.original.shape[1])
    print("Execution mode: ",sMode)
    if mode == 3:
        print("GPUs devices:", deviceCount)
    print("MNC value: ", cMnc)
    print("MNR value: ", cMnr)        
    print("Results:\n========================")
    print("Biclusters found: ", len(oModel.results))
    
    return oModel 

def __matrixReduce(data):
    patternSize = 64 # 64 bits
    rows, cols = data.shape
    
    if(cols % patternSize == 0):
        cols = int(cols / patternSize)
    else:
        cols = int(cols / patternSize) + 1
    
    
    for j in range(rows):
        cstr_rows_str_padded = ''.join(map(lambda x: str(int(x)), data[j])).zfill(cols * patternSize)       
        iPos = 0
        data[j] = 0
        for cWord in np.array(list(cstr_rows_str_padded), dtype=np.uint64).reshape(cols, patternSize):  
            data[j][iPos] = int(''.join(map(str, np.unpackbits(np.packbits(cWord)))), 2)
            iPos += 1
            
    return data[:, :cols]   

def __fillDataBiclusters(dataset, oModel):
    
    for oBicluster in oModel.results:
        dataBic = np.array([[0] * oBicluster.cols.shape[0]] * oBicluster.rows.shape[0])
        for i in range(oBicluster.rows.shape[0]):
            for j in range(oBicluster.cols.shape[0]):
                dataBic[i][j] = dataset.original[int(oBicluster.rows[i])][int(oBicluster.cols[j])]
        
        oBicluster.data = dataBic

##############################
# BiBit sequential algorithm #
##############################
def __bibitSequential(dataset, cMnr, cMnc, debug):
    
    aResultCols = np.zeros((maxPatterns, dataset.data.shape[1]), dtype=np.uint64)
    patFiltered = np.zeros(maxPatterns, dtype=np.longlong)
    
    # 1) Get patterns
    __getPatternsSequential(dataset, cMnc, aResultCols, patFiltered)

    # 2) Remove duplicate patterns
    patFiltered, aResultCols = __removeDuplicatePatterns(aResultCols, patFiltered)

    # 3) Generate biclusters
    oModel = __getBiclusters(dataset, cMnr, aResultCols, patFiltered, debug)        
    
    return oModel

def __getPatternsSequential(dataset, cMnc, aResultCols, patFiltered):
    idPattern = 0
    idValidPattern = 0
    for r1 in range(dataset.data.shape[0]):        
        for r2 in range(r1 + 1, dataset.data.shape[0]):
            
            totalOnes = 0
            rAnd = dataset.data[r1] & dataset.data[r2]
            
            for iDigit in rAnd:
                totalOnes += bin(iDigit)[2:].count('1')
            
            if(totalOnes >= cMnc):
                aResultCols[idPattern] = rAnd                    
                patFiltered[idValidPattern] = idPattern+1                 
                idValidPattern += 1                
            
            idPattern += 1

def __removeDuplicatePatterns(aResultCols, patFiltered):
    aResultColsWithout0 = aResultCols[~np.all(aResultCols == 0, axis=1)]
    uniqueValues, counts = np.unique(aResultColsWithout0, return_counts=True, axis = 0)
    duplicatedRows = uniqueValues[counts > 1]
    
    if duplicatedRows.size > 0:        
        duplicatePositions = []
        for value in duplicatedRows:
            positions = np.where(aResultCols == value)[0][1:]
            duplicatePositions.extend(positions)
        
        duplicatePositions = np.array(duplicatePositions)
        if duplicatePositions.size > 0:
            aResultCols[duplicatePositions] = 0
            duplicatePositions += 1
            for num in duplicatePositions:
                patFiltered[patFiltered == num] = 0
        
    posZeros = np.where(patFiltered == 0)[0]    
    if len(posZeros) > 0:
        patFiltered = np.delete(patFiltered,posZeros)
        
    posMinus1 = np.where(patFiltered == -1)[0]
    if len(posMinus1) > 0:
        patFiltered = np.delete(patFiltered,posMinus1)
    
    return patFiltered, aResultCols

def __getBiclusters(dataset, cMnr, aResultCols, patFiltered, debug):
    
    oBiBit = BiclusteringModel()        
    for pat in patFiltered: 
        rPattern = aResultCols[pat-1]
        aRows = np.where(((dataset.data & rPattern) == rPattern).all(axis=1))[0]
        
        if(aRows.size >= cMnr):
            
            if debug == False:
                                
                # Get columns
                binaryReprArray = np.array(list(np.binary_repr(rPattern[0])), dtype=int)
                zerosDifference = dataset.original.shape[1] - binaryReprArray.size # Conseguir el número de 0s que faltan por completar a la izquierda
                positionsCols = np.where(binaryReprArray == 1)[0]
                positionsCols += zerosDifference
                
                # Add bicluster to model
                oBiBit.results.add(Bicluster(aRows, cols=positionsCols))
            
            else:
                oBiBit.results.add(Bicluster(aRows))
    
    return oBiBit
                
#############################
# BiBit NUMBA CPU algorithm #
#############################
def __bibitNumbaCpu(dataset, cMnr, cMnc, debug):   
    
    warnings.filterwarnings("ignore", category=NumbaWarning)     
    set_num_threads(os.cpu_count())
    
    aResultCols = np.zeros((maxPatterns, dataset.data.shape[1]), dtype=np.uint64)
    patFiltered = np.zeros(maxPatterns, dtype=np.longlong)
    
    __getPatternsNumbaCpu(dataset.data, cMnc, aResultCols, patFiltered)
    patFiltered = patFiltered[patFiltered != 0]
    patFiltered, aResultCols = __removeDuplicatePatterns(aResultCols, patFiltered)
    
    biclusters = __generateBiclustersNumbaCpu(dataset.data, aResultCols, patFiltered)
    
    oBiBit = __storeResults(dataset, biclusters, aResultCols, patFiltered, cMnr, debug)

    return oBiBit

@njit(parallel=True)
def __getPatternsNumbaCpu(data, cMnc, aResultCols, patFiltered):
    
    rows = data.shape[0]
    idValidPattern = 0
    for r1 in prange(rows):        
        for r2 in prange(r1 + 1, rows):
            idPattern = (rows - 1) * r1 - (r1 * (r1 - 1) // 2) + (r2 - r1 - 1)
            totalOnes = 0
            rAnd = data[r1] & data[r2]
                        
            totalOnes = 0
            for n in rAnd:
                count = 0
                while n:
                    count += n & 1
                    n >>= 1
                totalOnes += count

            if(totalOnes >= cMnc):
                aResultCols[idPattern] = rAnd                    
                patFiltered[idPattern] = idPattern+1
                                    
@njit(parallel=True)
def __generateBiclustersNumbaCpu(data, aResultCols, patFiltered):
    maxBiclusters = len(patFiltered)
    biclusters = np.zeros((maxBiclusters, data.shape[0]), dtype=np.uint8)
    for i in prange(maxBiclusters):
        pat = patFiltered[i]-1
        for j in prange(data.shape[0]):
            if np.array_equal(data[j] & aResultCols[pat], aResultCols[pat]):
                biclusters[i, j] = 1           
                         
    return biclusters

def __storeResults(dataset, biclusters, aResultCols, patFiltered, cMnr, debug):
    oBiBit = BiclusteringModel()
    
    for i in range(len(patFiltered)):
        pat = patFiltered[i]-1
        rowsBiclusters = np.nonzero(biclusters[i])[0]        
        if(len(rowsBiclusters) >= cMnr):
            
            if debug == False:         
                vectorized_bin = np.vectorize(bin)
                binaryReprArray = vectorized_bin(aResultCols[pat])
                binaryReprArray = np.array(list(map(lambda s: s[2:], binaryReprArray)))
                totalBits = sum(len(s) for s in binaryReprArray)
                
                # Get columns
                zerosDifference = dataset.original.shape[1] - totalBits # Conseguir el número de 0s que faltan por completar a la izquierda
                binaryReprArray = np.array([list(binary_string) for binary_string in binaryReprArray])
                positionsCols = np.where(binaryReprArray == '1')[1]
                positionsCols += zerosDifference
                
                # Add bicluster to model
                oBiBit.results.add(Bicluster(rowsBiclusters, cols=positionsCols))
            
            else:
                oBiBit.results.add(Bicluster(rowsBiclusters))

    return oBiBit

#############################
# BiBit NUMBA GPU algorithm #
#############################
@cuda.jit
def __getPatterns(maxPatterns, aResultCols, id, bicsPerGpuPrevious, mInputData, totalPatterns, patternsPerRun, iter, totalFor, mnc, maxThreadsPerBlock):
    idTh = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x
    pattern = np.longlong(idTh + (totalFor * (iter - 1)) + (id * bicsPerGpuPrevious) + totalPatterns)
    patternCols = np.longlong(idTh + (totalFor * maxThreadsPerBlock * (iter - 1)))
    
    if patternCols < patternsPerRun and pattern < maxPatterns:
        r1 = 0
        r2 = -1
        auxPat = pattern - rowsDataset + 1
        if auxPat < 0:
            r2 = auxPat + rowsDataset
        j = rowsDataset - 2
        while(r2 == -1):
            auxPat = auxPat - j
            r1 += 1
            if auxPat < 0:
                r2 = (j + auxPat) + (r1 + 1)
            j -= 1

        if r1 < rowsDataset and r2 < rowsDataset:
            totalOnes = 0
            for j in range(colsDataset):
                rAnd = mInputData[r1][j] & mInputData[r2][j]
                aResultCols[patternCols][j] = rAnd
            
                while rAnd:
                    if(rAnd & 1 == 1):
                        totalOnes += 1
                    rAnd >>= 1

            if totalOnes < mnc:
                for j in range(colsDataset):
                    aResultCols[patternCols][j] = 0
                
    pass

@cuda.jit
def __generateBiclusters(aResultCols, mInputData, aResult, iter, totalFor, numPatFiltered, maxThreadsPerBlock):
    idTh = np.longlong(cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x + (totalFor * maxThreadsPerBlock * (iter - 1)))
    patternArray = idTh // rowsDataset
    row = idTh % rowsDataset
    if patternArray < numPatFiltered:
        #pattern = patFiltered[patternArray]-1       
        bEqual = True
        for k in range(colsDataset):
            rPattern = aResultCols[patternArray][k]
            if (mInputData[row][k] & rPattern) != rPattern:
                bEqual = False

        if bEqual:
            aResult[patternArray][row] = 1
        else:
            aResult[patternArray][row] = 0
    pass

@cuda.jit
def __generateBiclusters_no_out(aResultCols, mInputData, iter, totalFor, numPatFiltered, maxThreadsPerBlock, totalBiclusters, mnr):
    idTh = np.longlong(cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x + (totalFor * maxThreadsPerBlock * (iter - 1)))
    if idTh < numPatFiltered:
        numRows = 0
        row = 0
        while row in range(rowsDataset) and numRows < mnr:
            bEqual = True
            col = 0    
            while col in range(colsDataset) and bEqual:
                rPattern = aResultCols[row][col]
                if (mInputData[row][col] & rPattern) != rPattern:
                    bEqual = False
                col = col + 1
            
            if bEqual:
                numRows = numRows + 1
            row = row + 1

        cuda.atomic.add(totalBiclusters, 0, 1)

    pass

def __prepareGpu1D(i, lNumber):
    gpuDevice = cuda.select_device(i)
    maxThreadsCurrentGpu = gpuDevice.MAX_THREADS_PER_BLOCK
    maxGridSize = gpuDevice.MAX_GRID_DIM_Y
    
    global lastBlocksGrid, maxIteratorGPU, maxThreadsPerBlock, maxBlocksPerGrid
    
    lastBlocksGrid = 1
    maxIteratorGPU = 0
    maxThreadsPerBlock = lNumber  # Case 1: 0 < lNumber <= maxThreadsCurrentGpu
    maxBlocksPerGrid = 0

    if lNumber > maxThreadsCurrentGpu:  # Case 2: lNumber > maxThreadsCurrentGpu && Supported GPU in a for
        maxThreadsPerBlock = maxThreadsCurrentGpu
        maxBlocksPerGrid = lNumber // maxThreadsCurrentGpu
        lastBlocksGrid = lNumber // maxThreadsCurrentGpu
        
        if lNumber % maxThreadsCurrentGpu != 0:
            maxBlocksPerGrid += 1
            lastBlocksGrid += 1
        
        if maxBlocksPerGrid > maxGridSize:  # Case 3: Not supported GPU with a for --> Split patterns in multiple for
            maxIteratorGPU = maxBlocksPerGrid // maxGridSize
            lastBlocksGrid = maxBlocksPerGrid - (maxIteratorGPU * maxGridSize)
            maxBlocksPerGrid = maxGridSize
    
    lastBlocksGrid = int(lastBlocksGrid)
    maxIteratorGPU = int(maxIteratorGPU)
    maxThreadsPerBlock = int(maxThreadsPerBlock)
    maxBlocksPerGrid = int(maxBlocksPerGrid)
    
def __bibitNumbaGpu(dataset, cMnr, cMnc, deviceCount, debug):
    
    # 1) Prepare large-scale data (chunks) for GPUs
    warnings.filterwarnings("ignore", category=NumbaWarning)
    global rowsDataset, colsDataset, colsOriginalDataset, s, setPatterns64
    setPatterns64 = set()
    s = [cuda.stream() for _ in range(deviceCount)]
    chunks = np.empty(deviceCount, dtype=np.uint64)
    patternsPerRun = np.empty(deviceCount, dtype=np.uint64)
    bicsPerGpu = maxPatterns // deviceCount
    restBiclustersLastGpu = maxPatterns % deviceCount
    rowsDataset = dataset.data.shape[0]
    colsDataset = dataset.data.shape[1]
    colsOriginalDataset = dataset.original.shape[1]
    
    for i in range(deviceCount):            
        gpuDevice = cuda.select_device(i)
        s[i] = cuda.stream()
        totalGlobalMem = meminfo = cuda.current_context().get_memory_info()[1]
        availableMemory = ((3 * totalGlobalMem) // 4 - (rowsDataset * colsDataset * sys.getsizeof(np.uint64)))
        sizeResult=0
        if(debug == False):
            sizeResult = bicsPerGpu * rowsDataset * sys.getsizeof(np.uint8)
        sizeResultCols = bicsPerGpu * colsDataset * sys.getsizeof(np.uint64)
        chunks[i] = ((sizeResult + sizeResultCols) // availableMemory) + 1
        patternsPerRun[i] = bicsPerGpu // chunks[i]

        if bicsPerGpu % chunks[i] != 0:
            patternsPerRun[i] += 1
        if deviceCount > 1 and maxPatterns % deviceCount != 0 and i == deviceCount - 1:
            patternsPerRun[i] += restBiclustersLastGpu
        
    bicsPerGpuPrevious = 0 
    resultsQueue = queue.Queue()
    oBiBit = BiclusteringModel()        
    m = threading.Lock()
    threads = []  
       
    for i in range(deviceCount):
        gpuDevice = cuda.select_device(i)
        mInputData = cuda.to_device(np.ascontiguousarray(dataset.data))
        if i > 0:
            bicsPerGpuPrevious += np.longlong(chunks[i - 1] * patternsPerRun[i - 1])
        
        t = threading.Thread(target=threadsPerDevice_64, args=(resultsQueue, i, s[i], chunks[i], bicsPerGpuPrevious, patternsPerRun[i], mInputData, m, cMnr, cMnc, debug))
        t.start()
        threads.append(t)
    
    
    for th in threads:
        th.join()
    
    while not resultsQueue.empty():
        oModelo = resultsQueue.get()
        oBiBit.results = oBiBit.results.union(oModelo.results)
    
    return oBiBit

def threadsPerDevice_64(resultsQueue, i, s, chunks, bicsPerGpuPrevious, patternsPerRun, mInputData, m, cMnr, cMnc, debug):
    """
    Function used for the creation of a multi-GPU architecture.
    """
    gpuDevice = cuda.select_device(i)
    totalPatterns = np.uint64(0)
    totalBiclusters = cuda.to_device(np.array([0], dtype=np.uint64))
    sumBiclusters = 0
    
    for largeScale in range(chunks):     
        aResultCols = cuda.to_device(np.zeros((patternsPerRun,colsDataset), dtype=np.uint64))            
        
        # 1) Generate total patterns
        __prepareGpu1D(i, patternsPerRun)
        if(patternsPerRun != 0):
            with s.auto_synchronize():
                for it in range(1, maxIteratorGPU + 1):
                    __getPatterns[maxBlocksPerGrid, maxThreadsPerBlock, s](maxPatterns, aResultCols, i, bicsPerGpuPrevious, mInputData, totalPatterns, patternsPerRun, it, maxThreadsPerBlock*maxBlocksPerGrid, cMnc, maxThreadsPerBlock)
                __getPatterns[lastBlocksGrid, maxThreadsPerBlock, s](maxPatterns, aResultCols, i, bicsPerGpuPrevious, mInputData, totalPatterns, patternsPerRun, maxIteratorGPU+1, maxThreadsPerBlock*maxBlocksPerGrid, cMnc, maxThreadsPerBlock)
    
        # 2) Remove duplicate patterns
        aResultColsCpu = aResultCols.copy_to_host()        
        aResultColsCpu = aResultColsCpu[~np.all(aResultColsCpu == 0, axis=1)]
        aResultColsCpu = np.unique(aResultColsCpu, axis = 0)
        cpuNumPatFiltered = len(aResultColsCpu)
                
        del aResultCols
        aResultCols = cuda.to_device(np.zeros((cpuNumPatFiltered,colsDataset), dtype=np.uint64))
        aResultCols = cuda.to_device(aResultColsCpu)
        
        # 3) Generate biclusters
        if(cpuNumPatFiltered != 0):
            if(debug == False):
                aResult = cuda.to_device(np.full((patternsPerRun,rowsDataset), 0, dtype=np.uint8))
                __prepareGpu1D(i, cpuNumPatFiltered * rowsDataset)  
                with s.auto_synchronize():
                    for it in range(1, maxIteratorGPU + 1):
                        __generateBiclusters[maxBlocksPerGrid, maxThreadsPerBlock,s](aResultCols, mInputData, aResult, it, maxBlocksPerGrid, cpuNumPatFiltered, maxThreadsPerBlock)
                    __generateBiclusters[lastBlocksGrid, maxThreadsPerBlock,s](aResultCols, mInputData, aResult, maxIteratorGPU+1, maxBlocksPerGrid, cpuNumPatFiltered, maxThreadsPerBlock)
            else:
                __prepareGpu1D(i, cpuNumPatFiltered)
                with s.auto_synchronize():
                    for it in range(1, maxIteratorGPU + 1):
                        __generateBiclusters_no_out[maxBlocksPerGrid, maxThreadsPerBlock,s](aResultCols, mInputData, it, maxBlocksPerGrid, cpuNumPatFiltered, maxThreadsPerBlock, totalBiclusters, cMnr)
                    __generateBiclusters_no_out[lastBlocksGrid, maxThreadsPerBlock,s](aResultCols, mInputData, maxIteratorGPU+1, maxBlocksPerGrid, cpuNumPatFiltered, maxThreadsPerBlock, totalBiclusters, cMnr)
        
        # 4) Save biclusters
        aResultColsCpu = aResultCols.copy_to_host()
        aResultColsCpu = aResultColsCpu[~np.all(aResultColsCpu == 0, axis=1)]
        cpuNumPatFiltered = len(aResultColsCpu)
        
        oBiBit = BiclusteringModel()
        if(debug == False):
            aResultCpu = aResult.copy_to_host()
            for iIndex in range(cpuNumPatFiltered):  
                aRows = np.where(aResultCpu[iIndex] == 1)[0] # Rows of bicluster
                if(aRows.size >= cMnr):                    
                        aCols = np.array([], dtype=np.int64) # Cols of bicluster                    
                        j = colsDataset - 1
                        while j >= 0:
                            binaryReprArray = bin(aResultColsCpu[iIndex][j])[2:]
                                                
                            if colsDataset == 1:
                                if(len(binaryReprArray) < colsOriginalDataset):
                                    binaryReprArray = binaryReprArray.zfill((colsOriginalDataset - len(binaryReprArray))+len(binaryReprArray))
                            else:
                                colsSaveBicluster = colsOriginalDataset - (64*(colsDataset-1))              
                                if j > 0:
                                    colsSaveBicluster = colsSaveBicluster + (64*j)                                                                                    
                                
                                colsSaveBicluster -= len(binaryReprArray)
                                binaryReprArray = binaryReprArray.zfill(colsSaveBicluster+len(binaryReprArray))
                            
                            positionsCols = [iCont for iCont, caracter in enumerate(binaryReprArray) if caracter == "1"]

                            
                            if len(positionsCols) > 0:
                                aCols = np.concatenate((aCols, positionsCols))                            
                                
                            j -= 1
                    
                        # Add bicluster to model
                        oBiBit.results.add(Bicluster(aRows, cols=aCols))
        else:
            cpuTotalBiclusters = totalBiclusters.copy_to_host()[0] 
            sumBiclusters += cpuTotalBiclusters
            for iIndex in range(cpuTotalBiclusters):
                oBiBit.results.add(Bicluster(np.empty((0))))        
       
        resultsQueue.put(oBiBit)
        
        totalBiclusters[0] = 0
        totalPatterns += patternsPerRun
        