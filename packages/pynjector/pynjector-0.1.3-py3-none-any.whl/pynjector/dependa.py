from inspect import Signature, Parameter
from typing import TYPE_CHECKING

from .cell import FORBIDDEN_TYPES


class DiDependaMeta(type):
    def __new__(cls, name: str, bases: tuple, namespace: dict[str, any]) -> type:
        if len(bases) == 0 or '__init__' in namespace:
            return super().__new__(cls, name, bases, namespace)

        annotations: dict[str, type] = namespace.get('__annotations__', {})

        required_attributes = {
            key: value for key, value in annotations.items()
            if not key.isupper() and namespace.get(key, None) is None
        }

        invalid_attributes = [attr for attr, typ in required_attributes.items() if typ in FORBIDDEN_TYPES]
        if invalid_attributes:
            raise ValueError(
                f"Required attributes ({', '.join(invalid_attributes)}) of {name!r} "
                f"class have default immutable types and cannot be used in DiDependa."
            )

        filtered_namespace = {
            key: value
            for key, value in namespace.items()
            if key not in required_attributes
        }

        new_class = super().__new__(cls, name, bases, filtered_namespace)

        def init(self, **kwargs):
            missing_attributes = [attr for attr in required_attributes if attr not in kwargs]
            if missing_attributes:
                raise ValueError(f"Missing required attributes: {', '.join(missing_attributes)}")

            for attr, value in kwargs.items():
                if attr not in required_attributes:
                    raise ValueError(f"Unexpected attribute {attr!r}")

                expected_type = required_attributes[attr]
                if not isinstance(value, expected_type):
                    raise TypeError(f"Attribute {attr!r} must be of type {expected_type}, but got {type(value)}.")

                setattr(self, attr, value)


        signature = Signature([
            Parameter(attr, Parameter.KEYWORD_ONLY, annotation=annotations[attr])
            for attr in required_attributes
        ])

        new_class.__signature__ = signature

        setattr(new_class, '__init__', init)

        return new_class


class DiDependa(metaclass=DiDependaMeta):
    """
    Base class for dependency-injected classes.
    -------------------------------------
    - Automatically generates an `__init__` method for subclasses.
    - Ensures all required attributes (annotated but without default values)
      must be passed as keyword arguments during instantiation.
    - Enforces type checking at runtime, ensuring that the provided arguments match
      their expected types.
    - Modifies `inspect.signature()` output so that it correctly reflects
      only the required attributes.

    What Type of Attributes It Parses:
    ----------------------------------
    - Only **static class attributes** with type annotations are processed.
    - Attributes that **are ignored**:
      - Class-level constants (ALL_CAPS).
      - Attributes with default values.
      - Static and class methods.
    """

    if TYPE_CHECKING:
        def __init__(self, /, **kwargs):
            """
            This placeholder constructor exists only for static type checking (mypy, PyCharm, etc.).
            At runtime, the actual `__init__` method is dynamically generated by the metaclass.
            """
            pass
