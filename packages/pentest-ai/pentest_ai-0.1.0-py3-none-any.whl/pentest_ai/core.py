import os
import json
import subprocess
import time
import sys
import argparse
from groq import Groq
from colorama import init, Fore, Style
from pyfiglet import Figlet

# Initialize colorama for colored text
init()

# Config file path
CONFIG_PATH = os.path.expanduser("~/.pentest_ai_config.json")

# Supported tools
TOOLS = ["nmap", "sqlmap", "aircrack-ng", "airodump-ng", "metasploit", "nikto", "hashid", "hashcat", "john"]

# Typing animation function
def type_text(text, delay=0.03):
    for char in text:
        print(char, end='', flush=True)
        time.sleep(delay)
    print()

# Display animated logo
def display_logo():
    f = Figlet(font='slant')
    logo = f.renderText("PenTest AI")
    colors = [Fore.RED, Fore.YELLOW, Fore.GREEN, Fore.CYAN, Fore.BLUE, Fore.MAGENTA]
    for i, line in enumerate(logo.splitlines()):
        color = colors[i % len(colors)]
        print(color + line + Style.RESET_ALL)
        time.sleep(0.2)
    type_text(f"{Fore.CYAN}{Style.BRIGHT}AI Pentesting Chatbot üéâ Powered by AKM Korishee Apurbo üöÄ{Style.RESET_ALL}", delay=0.05)

def load_api_key():
    """Load API key from config file."""
    if os.path.exists(CONFIG_PATH):
        with open(CONFIG_PATH, 'r') as f:
            config = json.load(f)
            return config.get("api_key")
    return None

def save_api_key(api_key):
    """Save API key to config file."""
    config = {"api_key": api_key}
    with open(CONFIG_PATH, 'w') as f:
        json.dump(config, f)
    print(f"{Fore.GREEN}{Style.BRIGHT}API key saved to {CONFIG_PATH}! üéâ{Style.RESET_ALL}")

def validate_api_key(api_key):
    """Validate the API key by initializing Groq client."""
    try:
        client = Groq(api_key=api_key)
        client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=[{"role": "system", "content": "Test"}],
            max_tokens=1
        )
        return True
    except Exception:
        return False

def check_xterm_installed():
    """Check if xterm is installed."""
    try:
        subprocess.run(["xterm", "-version"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def install_xterm():
    """Attempt to install xterm using apt (for Debian-based systems like Kali)."""
    type_text(f"{Fore.YELLOW}{Style.BRIGHT}xterm is not installed! üî• Would you like to install it now? (y/n): {Style.RESET_ALL}", delay=0.03)
    response = input().strip().lower()
    if response == 'y' or response == '':
        try:
            type_text(f"{Fore.CYAN}{Style.BRIGHT}Installing xterm... üöÄ{Style.RESET_ALL}")
            subprocess.run(["sudo", "apt", "update"], check=True)
            subprocess.run(["sudo", "apt", "install", "-y", "xterm"], check=True)
            type_text(f"{Fore.GREEN}{Style.BRIGHT}xterm installed successfully! üéâ{Style.RESET_ALL}")
            return True
        except subprocess.CalledProcessError as e:
            type_text(f"{Fore.RED}{Style.BRIGHT}Failed to install xterm: {str(e)} üòû{Style.RESET_ALL}")
            return False
    else:
        type_text(f"{Fore.RED}{Style.BRIGHT}Cannot proceed without xterm. Please install it manually or use another terminal emulator. üö´{Style.RESET_ALL}")
        return False

def run_in_new_terminal(command):
    """Execute a command in a new terminal without pre-validation for continuous commands."""
    try:
        full_command = f"xterm -hold -e '{command}'"
        subprocess.Popen(full_command, shell=True)
        return "Command executed in a new terminal window! üéâ", None
    except Exception as e:
        return None, f"Unexpected error running command: {str(e)} üòµ"

def get_groq_response(client, user_input, chat_history=None):
    """Get response from Groq API using llama-3.3-70b-versatile."""
    if chat_history is None:
        chat_history = []

    system_prompt = (
        "You are 'Korishee,' an expert AI pentesting assistant running on Kali Linux üåê, created by AKM Korishee Apurbo. "
        "Guide the user interactively to build a pentesting command step-by-step. "
        "Respond with ONLY these three elements when generating a command:\n"
        "1. 'COMMAND: <full_command>' (no backticks, use placeholders like <hash> or <file> only if input is incomplete)\n"
        "2. 'EXPLANATION: <brief explanation>'\n"
        "3. 'QUESTION: <question>' with emojis ü§î (omit if no further input needed)\n"
        "For other inputs:\n"
        "- If vague (e.g., 'hi'), respond with a greeting and 'QUESTION: <question>'\n"
        "- If asked for your name, say 'I‚Äôm Korishee, your pentesting sidekick! üî•'\n"
        "- If asked for your creator, say 'I was crafted by the awesome AKM Korishee Apurbo! üöÄ'\n"
        "Keep it fun, concise, and engaging! üòé"
    )

    messages = [{"role": "system", "content": system_prompt}] + chat_history + [{"role": "user", "content": user_input}]
    try:
        response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=messages,
            max_tokens=300,
            temperature=0.5
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        return f"Oops! Something went wrong with the AI: {str(e)} üò¢"

def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Pentest-AI: AI-powered pentesting tool")
    parser.add_argument("--api", type=str, help="Set the Groq API key")
    args = parser.parse_args()

    # Load or set API key
    api_key = load_api_key()
    if args.api:
        if validate_api_key(args.api):
            save_api_key(args.api)
            api_key = args.api
        else:
            print(f"{Fore.RED}{Style.BRIGHT}Invalid API key provided! üòû Please check and try again.{Style.RESET_ALL}")
            sys.exit(1)
    elif not api_key:
        print(f"{Fore.RED}{Style.BRIGHT}No API key found! üò± Please run 'pentest-ai --api <your_api_key>' first.{Style.RESET_ALL}")
        sys.exit(1)

    # Check and install xterm if needed
    if not check_xterm_installed():
        if not install_xterm():
            sys.exit(1)

    # Initialize Groq client
    client = Groq(api_key=api_key)

    # Main program
    display_logo()
    type_text(f"{Fore.GREEN}{Style.BRIGHT}Welcome to Pentest AI! üéâ Type 'exit' to quit. üö™{Style.RESET_ALL}", delay=0.03)
    chat_history = []
    pending_command = None

    while True:
        # Show input prompt only once per iteration
        user_input = input(f"{Fore.YELLOW}{Style.BRIGHT}You üë§: {Style.RESET_ALL}")
        if user_input.lower() == "exit":
            type_text(f"{Fore.CYAN}{Style.BRIGHT}Goodbye! üëã Catch you later! üòÑ{Style.RESET_ALL}")
            break

        # Handle pending command with placeholders
        if pending_command:
            command = pending_command.replace("<hash>", user_input).replace("<file>", user_input).replace("<target_IP>", user_input)
            type_text(f"{Fore.MAGENTA}{Style.BRIGHT}Korishee üíÄ: {Fore.BLUE}{Style.BRIGHT}COMMAND: {command}{Style.RESET_ALL}")
            result, error = run_in_new_terminal(command)
            if result:
                type_text(f"{Fore.GREEN}{Style.BRIGHT}{result} üî•{Style.RESET_ALL}")
            elif error:
                type_text(f"{Fore.RED}{Style.BRIGHT}Oops! Error üò±: {error}{Style.RESET_ALL}")
            pending_command = None
            continue

        # Process new input
        chat_history.append({"role": "user", "content": user_input})
        ai_response = get_groq_response(client, user_input, chat_history)
        
        # Parse and handle response with distinct bold colors
        command = None
        question_present = False
        response_text = ""
        lines = ai_response.split("\n")
        for line in lines:
            if line.startswith("COMMAND:"):
                command = line.replace("COMMAND: ", "").strip()
                type_text(f"{Fore.MAGENTA}{Style.BRIGHT}Korishee üíÄ: {Fore.BLUE}{Style.BRIGHT}COMMAND: {command}{Style.RESET_ALL}")
            elif line.startswith("EXPLANATION:"):
                type_text(f"{Fore.CYAN}{Style.BRIGHT}Explanation üìù: {line.replace('EXPLANATION: ', '')}{Style.RESET_ALL}")
            elif line.startswith("QUESTION:"):
                question_present = True
                response_text = line.replace("QUESTION: ", "").strip()
            else:
                response_text += line + "\n"

        # Display main response (if any) before the question
        if response_text and not question_present:
            type_text(f"{Fore.MAGENTA}{Style.BRIGHT}Korishee üíÄ: {response_text.strip()}{Style.RESET_ALL}")

        # Display question as "Korishee asks" on a new line
        if question_present:
            type_text(f"{Fore.GREEN}{Style.BRIGHT}Korishee asks ‚ùì: {response_text}{Style.RESET_ALL}")

        if command and all(x not in command for x in ["<", ">"]):
            result, error = run_in_new_terminal(command)
            if result:
                type_text(f"{Fore.GREEN}{Style.BRIGHT}{result} üî•{Style.RESET_ALL}")
            elif error:
                type_text(f"{Fore.RED}{Style.BRIGHT}Oops! Error üò±: {error}{Style.RESET_ALL}")
        elif command:
            pending_command = command

        chat_history.append({"role": "assistant", "content": ai_response})

if __name__ == "__main__":
    main()
