-- pyproject.toml --
[project]
name = "mildmouse"
version = "0.1.0"
description = "Google Custom Search API client"
readme = "README.md"
authors = [
    { name = "Taylor Monacelli", email = "taylormonacelli@gmail.com" }
]
requires-python = ">=3.12"
dependencies = [
    "python-dotenv>=1.0.0",
    "platformdirs>=3.0.0",
]

[project.scripts]
mildmouse = "mildmouse.cli:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
-- src/mildmouse/__init__.py --
"""Google Custom Search Engine client package."""

from .search import search_google
from .formatter import format_search_results, pretty_print_results
from .cache import get_cache_path, load_cache, save_cache

__all__ = [
    "search_google",
    "format_search_results",
    "pretty_print_results",
    "get_cache_path",
    "load_cache",
    "save_cache",
]
-- src/mildmouse/cache.py --
"""Cache handling for search results."""

import json
import logging
import os
import time
from pathlib import Path
from platformdirs import user_config_dir

logger = logging.getLogger(__name__)
APP_NAME = "mildmouse"


def get_cache_path():
    """
    Get the path to the cache file.

    Returns:
        Path: Path to the cache file
    """
    cache_dir = Path(user_config_dir(APP_NAME))
    return cache_dir / "cache.json"


def load_cache():
    """
    Load the cache from disk.

    Returns:
        dict: The cache contents or empty dict if no cache exists
    """
    cache_path = get_cache_path()

    if not cache_path.exists():
        logger.debug(f"No cache file found at {cache_path}")
        return {}

    try:
        with open(cache_path, "r") as f:
            logger.debug(f"Loading cache from {cache_path}")
            return json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        logger.warning(f"Failed to load cache: {e}")
        return {}


def save_cache(cache):
    """
    Save the cache to disk.

    Args:
        cache (dict): The cache to save
    """
    cache_path = get_cache_path()

    # Ensure directory exists
    os.makedirs(cache_path.parent, exist_ok=True)

    try:
        with open(cache_path, "w") as f:
            logger.debug(f"Saving cache to {cache_path}")
            json.dump(cache, f, indent=2)
    except IOError as e:
        logger.warning(f"Failed to save cache: {e}")


def get_cache_key(query, cx, start, num, safe, fields):
    """
    Generate a cache key for the search parameters.

    Args:
        query (str): Search query
        cx (str): Custom Search Engine ID
        start (int): Starting index
        num (int): Number of results
        safe (str): Safe search setting
        fields (str): Fields to return

    Returns:
        str: Cache key
    """
    # Create a tuple of all parameters that affect the search results
    params = (query, cx, start, num, safe, fields or "")

    # Convert to a string that can be used as a key
    return json.dumps(params, sort_keys=True)


def get_from_cache(
    query, cx, start, num, safe, fields, max_age=86400, ignore_cache=False
):
    """
    Try to get search results from cache.

    Args:
        query (str): Search query
        cx (str): Custom Search Engine ID
        start (int): Starting index
        num (int): Number of results
        safe (str): Safe search setting
        fields (str): Fields to return
        max_age (int): Maximum age of cached results in seconds (default: 24 hours)
        ignore_cache (bool): If True, bypass the cache completely

    Returns:
        tuple: (results, from_cache) where results is the search results (or None if not found)
               and from_cache is a boolean indicating whether the results came from cache
    """
    if ignore_cache:
        logger.info("Cache ignored as requested")
        return None, False

    cache = load_cache()
    cache_key = get_cache_key(query, cx, start, num, safe, fields)

    if cache_key in cache:
        cache_entry = cache[cache_key]
        cache_time = cache_entry.get("timestamp", 0)
        current_time = time.time()

        # Check if cache entry is still valid
        if current_time - cache_time <= max_age:
            logger.info(f"Cache HIT for query: {query}")
            return cache_entry.get("results"), True
        else:
            logger.info(
                f"Cache EXPIRED for query: {query} (age: {int(current_time - cache_time)} seconds)"
            )
    else:
        logger.info(f"Cache MISS for query: {query}")

    return None, False


def save_to_cache(query, cx, start, num, safe, fields, results):
    """
    Save search results to cache.

    Args:
        query (str): Search query
        cx (str): Custom Search Engine ID
        start (int): Starting index
        num (int): Number of results
        safe (str): Safe search setting
        fields (str): Fields to return
        results (dict): Search results to cache
    """
    cache = load_cache()
    cache_key = get_cache_key(query, cx, start, num, safe, fields)

    cache[cache_key] = {"timestamp": time.time(), "results": results}

    save_cache(cache)
    logger.info(f"Saved results to cache for query: {query}")
-- src/mildmouse/cli.py --
"""Command-line interface for the mildmouse package."""

import argparse
import json
import sys
import logging
from .config import (
    load_environment_variables,
    create_env_sample,
    create_env_file,
    get_credentials,
    setup_logging,
    get_config_paths,
)
from .search import search_google
from .formatter import pretty_print_results
from .cache import get_cache_path

logger = logging.getLogger(__name__)


def search_command(args):
    """
    Execute the search command.
    Args:
        args: Parsed arguments namespace
    """
    # Set up default credentials now, after env has been loaded
    credentials = get_credentials()
    if args.key is None:
        args.key = credentials[0]
    if args.cx is None:
        args.cx = credentials[1]

    # Join query terms if provided as separate arguments
    query = " ".join(args.query) if args.query else ""

    # Check for required parameters
    if not query:
        print("Error: Search query is required")
        return 1
    if not args.key:
        print(
            "Error: Google API key is required (use --key or set GOOGLE_API_KEY env variable)"
        )
        print("Use 'mildmouse config --create-sample' to create a sample .env file")
        print("See README.md for setup instructions")
        return 1
    if not args.cx:
        print(
            "Error: Custom Search Engine ID is required (use --cx or set GOOGLE_SEARCH_CX env variable)"
        )
        print("Use 'mildmouse config --create-sample' to create a sample .env file")
        print("See README.md for setup instructions")
        return 1

    logger.info(f"Searching for: {query}")
    try:
        # Perform search
        results = search_google(
            query=query,
            api_key=args.key,
            cx=args.cx,
            num=args.num,
            start=args.start,
            ignore_cache=args.no_cache,
            cache_max_age=args.cache_age,
        )

        # Output results
        if args.json:
            print(json.dumps(results, indent=2))
        else:
            pretty_print_results(results)

        return 0
    except Exception as e:
        logger.error(f"Error during search: {str(e)}")
        print(f"Error: {e}", file=sys.stderr)
        return 1


def config_command(args):
    """
    Execute the config command.
    Args:
        args: Parsed arguments namespace
    """
    # Handle --list flag
    if args.list:
        paths = get_config_paths()
        print("Configuration paths:")
        for name, path in paths.items():
            print(f"  {name}: {path}")
            print(f"    (exists: {path.exists()})")

        # Also show cache file
        cache_path = get_cache_path()
        print(f"  cache_file: {cache_path}")
        print(f"    (exists: {cache_path.exists()})")

        return 0

    # Handle --create-sample flag
    if args.create_sample:
        # Use user config dir by default for --create-sample
        # unless explicitly set to false
        in_user_config = True
        if hasattr(args, "user_config") and args.user_config is False:
            in_user_config = False

        env_sample_path = create_env_sample(in_user_config)
        if in_user_config:
            # Get the path for the actual .env file in the same directory
            config_dir = env_sample_path.parent
            env_file_path = config_dir / ".env"
            print(f"Created sample environment file at {env_sample_path}")
            print(f"Copy or rename this file to {env_file_path}")
            print("Fill in your API key and Search Engine ID")
        else:
            print(f"Created sample environment file at {env_sample_path}")
            print("Copy this to .env and fill in your API key and Search Engine ID")

        print("See README.md for detailed setup instructions")
        return 0

    # Handle --create flag
    if args.create:
        if not args.key or not args.cx:
            print("Error: --create requires both --key and --cx to be provided")
            return 1

        # Use user config dir by default for --create
        # unless explicitly set to false
        in_user_config = True
        if hasattr(args, "user_config") and args.user_config is False:
            in_user_config = False

        env_path = create_env_file(args.key, args.cx, in_user_config)
        print(f"Created .env file at {env_path} with your credentials")
        return 0

    # If no specific action is specified, show the current config
    api_key, cx = get_credentials()
    key_status = "Set" if api_key else "Not set"
    cx_status = "Set" if cx else "Not set"

    paths = get_config_paths()
    print("Current configuration:")
    print(f"  GOOGLE_API_KEY: {key_status}")
    print(f"  GOOGLE_SEARCH_CX: {cx_status}")

    print("\nConfiguration files:")
    for name, path in paths.items():
        if "env_file" in name:  # Only show .env files, not directories
            print(f"  {name}: {path}")
            print(f"    (exists: {path.exists()})")

    return 0


def setup_parsers():
    """
    Set up command-line argument parsers.
    Returns:
        main_parser: The main argument parser
    """
    # Create main parser
    main_parser = argparse.ArgumentParser(
        description="Google Custom Search Engine command-line client"
    )
    main_parser.add_argument(
        "--verbose",
        "-v",
        action="count",
        default=0,
        help="Increase verbosity (-v for info, -v -v for debug)",
    )

    # Create subparsers
    subparsers = main_parser.add_subparsers(dest="command", help="Command to execute")

    # Search command
    search_parser = subparsers.add_parser(
        "search", help="Search Google Custom Search Engine"
    )
    search_parser.add_argument(
        "query", nargs="*", help="Search query (use quotes for multi-word queries)"
    )
    search_parser.add_argument(
        "--key",
        "-k",
        help="Google API key (can also be set via GOOGLE_API_KEY env variable)",
    )
    search_parser.add_argument(
        "--cx",
        "-c",
        help="Custom Search Engine ID (can also be set via GOOGLE_SEARCH_CX env variable)",
    )
    search_parser.add_argument(
        "--num",
        "-n",
        type=int,
        default=10,
        help="Number of results to return (max 10, default: 10)",
    )
    search_parser.add_argument(
        "--start",
        "-s",
        type=int,
        default=1,
        help="Index of first result (1-based, default: 1)",
    )
    search_parser.add_argument(
        "--json", "-j", action="store_true", help="Output results as JSON"
    )
    search_parser.add_argument(
        "--no-cache",
        action="store_true",
        help="Ignore cache and force a fresh API request",
    )
    search_parser.add_argument(
        "--cache-age",
        type=int,
        default=86400,
        help="Maximum age of cached results in seconds (default: 24 hours)",
    )

    # Config command
    config_parser = subparsers.add_parser(
        "config", help="Manage configuration settings"
    )
    config_parser.add_argument(
        "--list", "-l", action="store_true", help="List all configuration paths"
    )
    config_parser.add_argument(
        "--create-sample", action="store_true", help="Create a sample .env.sample file"
    )
    config_parser.add_argument(
        "--create",
        action="store_true",
        help="Create .env file with provided credentials (requires --key and --cx)",
    )
    config_parser.add_argument("--key", "-k", help="Google API key for --create")
    config_parser.add_argument(
        "--cx", "-c", help="Custom Search Engine ID for --create"
    )
    config_parser.add_argument(
        "--local",
        action="store_false",
        dest="user_config",
        help="Use current directory instead of user config directory for file operations",
    )

    return main_parser


def main() -> int:
    """
    Run the command-line interface.
    Returns:
        int: Exit code (0 for success, non-zero for error)
    """
    # Set up parsers
    parser = setup_parsers()

    # Parse arguments
    args = parser.parse_args()

    # Set up logging based on verbosity level
    setup_logging(args.verbose)
    logger.debug(f"Starting mildmouse with arguments: {args}")

    # Load environment variables ONLY from .env, never from .env.sample
    load_environment_variables()
    logger.debug("Environment variables loaded")

    # Handle commands
    if args.command == "search":
        return search_command(args)
    elif args.command == "config":
        return config_command(args)
    else:
        # If no command specified, default to showing help
        parser.print_help()
        return 0


if __name__ == "__main__":
    sys.exit(main())
-- src/mildmouse/config.py --
"""Configuration handling for the mildmouse package."""

import os
import logging
from pathlib import Path
from dotenv import load_dotenv
from platformdirs import user_config_dir

logger = logging.getLogger(__name__)

APP_NAME = "mildmouse"


def get_config_paths():
    """
    Get paths for config files.

    Returns:
        dict: Paths for various configuration locations
    """
    # Get user config directory
    user_config = Path(user_config_dir(APP_NAME))

    return {
        "user_config_dir": user_config,
        "user_env_file": user_config / ".env",
        "user_env_sample": user_config / ".env.sample",
        "local_env_file": Path.cwd() / ".env",
        "local_env_sample": Path.cwd() / ".env.sample",
        "home_env_file": Path.home() / ".env",
    }


def load_environment_variables():
    """
    Load environment variables from .env files.

    Checks in multiple locations with the following priority:
    1. Current directory
    2. User config directory
    3. Home directory
    """
    paths = get_config_paths()
    env_loaded = False

    # Try loading from current directory first
    if paths["local_env_file"].exists():
        logger.info(f"Loading environment from: {paths['local_env_file']}")
        load_dotenv(paths["local_env_file"])
        env_loaded = True

    # Then try user config directory
    if paths["user_env_file"].exists():
        logger.info(f"Loading environment from: {paths['user_env_file']}")
        load_dotenv(paths["user_env_file"])
        env_loaded = True

    # Finally try home directory
    if paths["home_env_file"].exists():
        logger.info(f"Loading environment from: {paths['home_env_file']}")
        load_dotenv(paths["home_env_file"])
        env_loaded = True

    if not env_loaded:
        logger.warning("No .env file found in any of the standard locations")
        logger.info(
            f"Checked: {paths['local_env_file']}, {paths['user_env_file']}, {paths['home_env_file']}"
        )


def get_credentials():
    """
    Get API credentials from environment variables.

    Returns:
        Tuple of (api_key, cx)
    """
    api_key = os.environ.get("GOOGLE_API_KEY", "")
    cx = os.environ.get("GOOGLE_SEARCH_CX", "")

    # Debug env vars if they're not found
    if not api_key or not cx:
        logger.debug(
            f"Environment variables: GOOGLE_API_KEY={'set' if api_key else 'not set'}, GOOGLE_SEARCH_CX={'set' if cx else 'not set'}"
        )
        # List all env vars for debugging (only at debug level)
        logger.debug(f"All environment variables: {list(os.environ.keys())}")

    return api_key, cx


def create_env_sample(in_user_config=False):
    """
    Create a sample .env file to demonstrate the format.

    Args:
        in_user_config: If True, create in user config dir instead of current dir

    Returns:
        Path to the created file
    """
    paths = get_config_paths()

    if in_user_config:
        # Make sure the directory exists
        os.makedirs(paths["user_config_dir"], exist_ok=True)
        target_path = paths["user_env_sample"]
    else:
        target_path = paths["local_env_sample"]

    with open(target_path, "w") as f:
        f.write("# Google Custom Search Engine credentials\n")
        f.write(
            "# Get your API key from https://developers.google.com/custom-search/v1/overview\n"
        )
        f.write(
            "# Create a custom search engine at https://programmablesearchengine.google.com/\n"
        )
        f.write(
            "# The Search Engine ID (cx) is shown in the 'Setup' section after creation\n"
        )
        f.write("GOOGLE_API_KEY=your_api_key_here\n")
        f.write("GOOGLE_SEARCH_CX=your_search_engine_id_here\n")

    return target_path


def create_env_file(api_key, cx, in_user_config=False):
    """
    Create a .env file with the provided credentials.

    Args:
        api_key: Google API key
        cx: Custom Search Engine ID
        in_user_config: If True, create in user config dir instead of current dir

    Returns:
        Path to the created file
    """
    paths = get_config_paths()

    if in_user_config:
        # Make sure the directory exists
        os.makedirs(paths["user_config_dir"], exist_ok=True)
        target_path = paths["user_env_file"]
    else:
        target_path = paths["local_env_file"]

    with open(target_path, "w") as f:
        f.write("# Google Custom Search Engine credentials\n")
        f.write(f"GOOGLE_API_KEY={api_key}\n")
        f.write(f"GOOGLE_SEARCH_CX={cx}\n")

    return target_path


def setup_logging(verbosity=0):
    """
    Configure logging based on verbosity level.

    Args:
        verbosity: 0=warning, 1=info, 2+=debug
    """
    root_logger = logging.getLogger()

    # Set log level based on verbosity
    if verbosity == 0:
        level = logging.WARNING
    elif verbosity == 1:
        level = logging.INFO
    else:
        level = logging.DEBUG

    # Configure handler if not already configured
    if not root_logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        handler.setFormatter(formatter)
        root_logger.addHandler(handler)

    root_logger.setLevel(level)

    # Log the logging level being set
    if level == logging.WARNING:
        pass  # Don't log at warning level
    elif level == logging.INFO:
        logging.info("Verbose logging enabled (info level)")
    elif level == logging.DEBUG:
        logging.info("Debug logging enabled (debug level)")
-- src/mildmouse/exceptions.py --
"""Custom exceptions for the mildmouse package."""


class SearchError(Exception):
    """Exception raised for errors during the search process."""

    pass


class APIError(SearchError):
    """Exception raised for errors from the Google API."""

    def __init__(self, status_code, message):
        self.status_code = status_code
        self.message = message
        super().__init__(f"API Error ({status_code}): {message}")


class ConfigError(Exception):
    """Exception raised for configuration errors."""

    pass
-- src/mildmouse/formatter.py --
"""Formatting utilities for search results."""

from typing import Any, Dict, List


def format_search_results(results: Dict[str, Any]) -> List[Dict[str, str]]:
    """
    Format Google search results into a simplified list.

    Args:
        results: Response from the Google Custom Search API

    Returns:
        List of dictionaries with title, link, and snippet
    """
    formatted_results = []

    if "items" not in results:
        return formatted_results

    for item in results.get("items", []):
        formatted_results.append(
            {
                "title": item.get("title", ""),
                "link": item.get("link", ""),
                "snippet": item.get("snippet", ""),
            }
        )

    return formatted_results


def pretty_print_results(results: Dict[str, Any]) -> None:
    """
    Print search results in a human-readable format.

    Args:
        results: Response from the Google Custom Search API
    """
    if "items" not in results:
        print("No results found.")
        return

    print(
        f"About {results.get('searchInformation', {}).get('formattedTotalResults', '0')} results "
        f"({results.get('searchInformation', {}).get('formattedSearchTime', '0')} seconds)"
    )
    print("-" * 80)

    for i, item in enumerate(results.get("items", []), 1):
        print(f"{i}. {item.get('title', '')}")
        print(f"   {item.get('link', '')}")
        print(f"   {item.get('snippet', '')}")
        print()
-- src/mildmouse/search.py --
"""Google Custom Search Engine API interface."""

import json
import logging
import urllib.request
import urllib.parse
import urllib.error
from typing import Any, Dict, Optional

from .cache import get_from_cache, save_to_cache

logger = logging.getLogger(__name__)


def search_google(
    query: str,
    api_key: str,
    cx: str,
    start: int = 1,
    num: int = 10,
    safe: str = "off",
    fields: Optional[str] = None,
    ignore_cache: bool = False,
    cache_max_age: int = 86400,
) -> Dict[str, Any]:
    """
    Search Google using the Custom Search JSON API.
    Args:
        query: Search query string
        api_key: Google API key
        cx: Custom Search Engine ID
        start: Index of first result (1-based, default: 1)
        num: Number of results to return (max 10, default: 10)
        safe: Safe search level ('off', 'medium', 'high', default: 'off')
        fields: Comma-separated list of fields to include in the response
        ignore_cache: If True, bypass the cache and force a fresh API request
        cache_max_age: Maximum age of cached results in seconds (default: 24 hours)
    Returns:
        Dict containing the search results
    """
    # Try to get from cache first if not ignoring cache
    cached_results, from_cache = get_from_cache(
        query,
        cx,
        start,
        num,
        safe,
        fields,
        max_age=cache_max_age,
        ignore_cache=ignore_cache,
    )

    if from_cache:
        return cached_results

    # If not in cache or ignoring cache, perform the search
    base_url = "https://www.googleapis.com/customsearch/v1"
    params = {
        "q": query,
        "key": api_key,
        "cx": cx,
        "start": start,
        "num": num,
        "safe": safe,
    }
    if fields:
        params["fields"] = fields
    url = f"{base_url}?{urllib.parse.urlencode(params)}"

    # Log request (with API key partially masked)
    masked_params = params.copy()
    if masked_params.get("key"):
        key = masked_params["key"]
        if len(key) > 8:
            masked_params["key"] = key[:4] + "..." + key[-4:]
        else:
            masked_params["key"] = "****"
    logger.info("Sending request to Google Custom Search API")
    logger.debug(f"Request URL: {base_url}")
    logger.debug(f"Request parameters: {masked_params}")

    try:
        request = urllib.request.Request(url)
        with urllib.request.urlopen(request) as response:
            response_data = response.read().decode("utf-8")
            result = json.loads(response_data)
            logger.info(f"Received response with status: {response.status}")
            logger.debug(f"Response headers: {dict(response.getheaders())}")
            logger.debug(f"Response JSON: {json.dumps(result, indent=2)}")

            # Save to cache if successful
            save_to_cache(query, cx, start, num, safe, fields, result)

            return result
    except urllib.error.HTTPError as e:
        error_message = e.read().decode("utf-8")
        logger.error(f"HTTP Error {e.code}: {error_message}")
        raise RuntimeError(f"HTTP Error {e.code}: {error_message}")
    except Exception as e:
        logger.error(f"Error during API request: {str(e)}")
        raise
